<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="StudySettings">
    <StudyTaskManager>
      <option name="VERSION" value="16" />
      <option name="myUserTests">
        <map />
      </option>
      <option name="course">
        <HyperskillCourse>
          <option name="authors">
            <list />
          </option>
          <option name="courseMode" value="Study" />
          <option name="customPresentableName" />
          <option name="description" value="For those who are learning a foreign language, it’s a challenge to remember new words, which is exactly what flashcards are for. Typically, flashcards show a hint (a task or a picture) on the one side and the right answer on the reverse. Flashcards can be used to remember any other sort of data: so if you want to create something useful and enhance your programming skills, this project is just right.&lt;br/&gt;&lt;br/&gt;Learn more at &lt;a href=&quot;https://hyperskill.org&quot;&gt;https://hyperskill.org/projects/44&lt;/a&gt;" />
          <option name="environment" value="" />
          <option name="id" value="0" />
          <option name="index" value="-1" />
          <option name="language" value="JAVA 11" />
          <option name="languageCode" value="en" />
          <option name="name" value="Flashcards (Java)" />
          <option name="stages">
            <list>
              <HyperskillStage>
                <option name="id" value="232" />
                <option name="stepId" value="5343" />
                <option name="title" value="Stage one, card one" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="233" />
                <option name="stepId" value="5344" />
                <option name="title" value="What’s on the card?" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="234" />
                <option name="stepId" value="5345" />
                <option name="title" value="Make it your own" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="235" />
                <option name="stepId" value="5346" />
                <option name="title" value="A good stack" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="236" />
                <option name="stepId" value="5347" />
                <option name="title" value="Menu, please!" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="237" />
                <option name="stepId" value="5348" />
                <option name="title" value="Statistics" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="238" />
                <option name="stepId" value="5349" />
                <option name="title" value="IMPORTant" />
              </HyperskillStage>
            </list>
          </option>
          <option name="taskToTopics">
            <map>
              <entry key="0">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="259" />
                      <option name="theoryId" value="3805" />
                      <option name="title" value="IDE" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="15" />
                      <option name="theoryId" value="3500" />
                      <option name="title" value="Introduction to Java" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="147" />
                      <option name="theoryId" value="3522" />
                      <option name="title" value="Basic literals" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="148" />
                      <option name="theoryId" value="3521" />
                      <option name="title" value="The first program" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="193" />
                      <option name="theoryId" value="3749" />
                      <option name="title" value="Printing data" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="260" />
                      <option name="theoryId" value="3801" />
                      <option name="title" value="IntelliJ IDEA" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="1">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="480" />
                      <option name="theoryId" value="6577" />
                      <option name="title" value="Command line overview" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="14" />
                      <option name="theoryId" value="3518" />
                      <option name="title" value="Types and variables" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="30" />
                      <option name="theoryId" value="3520" />
                      <option name="title" value="Comments" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="112" />
                      <option name="theoryId" value="3513" />
                      <option name="title" value="Naming variables" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="146" />
                      <option name="theoryId" value="3519" />
                      <option name="title" value="Arithmetic operations" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="191" />
                      <option name="theoryId" value="3739" />
                      <option name="title" value="Write, compile and run" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="149" />
                      <option name="theoryId" value="3499" />
                      <option name="title" value="JVM, JRE and JDK" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="192" />
                      <option name="theoryId" value="3746" />
                      <option name="title" value="Running programs on your computer" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="113" />
                      <option name="theoryId" value="3603" />
                      <option name="title" value="Scanning the input" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="27" />
                      <option name="theoryId" value="3565" />
                      <option name="title" value="Integer types and operations" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="87" />
                      <option name="theoryId" value="3516" />
                      <option name="title" value="Boolean and logical operations" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="88" />
                      <option name="theoryId" value="3512" />
                      <option name="title" value="Relational operators" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="307" />
                      <option name="theoryId" value="5008" />
                      <option name="title" value="Increment and decrement" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="31" />
                      <option name="theoryId" value="3514" />
                      <option name="title" value="Characters" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="9" />
                      <option name="theoryId" value="3523" />
                      <option name="title" value="String" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="25" />
                      <option name="theoryId" value="3503" />
                      <option name="title" value="Conditional statement" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="2">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="309" />
                      <option name="theoryId" value="5035" />
                      <option name="title" value="Primitive and reference types" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="4" />
                      <option name="theoryId" value="3511" />
                      <option name="title" value="Array" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="89" />
                      <option name="theoryId" value="3505" />
                      <option name="title" value="The for-loop" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="90" />
                      <option name="theoryId" value="3498" />
                      <option name="title" value="The while and do-while loops" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="19" />
                      <option name="theoryId" value="3507" />
                      <option name="title" value="Branching statements" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="97" />
                      <option name="theoryId" value="3602" />
                      <option name="title" value="Iterating over arrays" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="3">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="117" />
                      <option name="theoryId" value="3614" />
                      <option name="title" value="Introduction to OOP" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="502" />
                      <option name="theoryId" value="6865" />
                      <option name="title" value="Units of information" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="362" />
                      <option name="theoryId" value="5544" />
                      <option name="title" value="Binary numbers" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="60" />
                      <option name="theoryId" value="3497" />
                      <option name="title" value="What is an exception" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="59" />
                      <option name="theoryId" value="3570" />
                      <option name="title" value="Hierarchy of exceptions" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="65" />
                      <option name="theoryId" value="3552" />
                      <option name="title" value="Exception handling" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="167" />
                      <option name="theoryId" value="3492" />
                      <option name="title" value="Generic programming" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="43" />
                      <option name="theoryId" value="3591" />
                      <option name="title" value="Basics of collections" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="40" />
                      <option name="theoryId" value="3575" />
                      <option name="title" value="Set" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="46" />
                      <option name="theoryId" value="3558" />
                      <option name="title" value="Map" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="161" />
                      <option name="theoryId" value="3532" />
                      <option name="title" value="Sizes and ranges" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="32" />
                      <option name="theoryId" value="3510" />
                      <option name="title" value="Type casting" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="163" />
                      <option name="theoryId" value="3536" />
                      <option name="title" value="Errors in programs" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="94" />
                      <option name="theoryId" value="3590" />
                      <option name="title" value="Defining methods" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="115" />
                      <option name="theoryId" value="3618" />
                      <option name="title" value="Defining classes" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="7" />
                      <option name="theoryId" value="3621" />
                      <option name="title" value="Package" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="17" />
                      <option name="theoryId" value="3535" />
                      <option name="title" value="Constructor" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="96" />
                      <option name="theoryId" value="4727" />
                      <option name="title" value="Objects" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="6" />
                      <option name="theoryId" value="3595" />
                      <option name="title" value="Boxing &amp;&amp; unboxing" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="116" />
                      <option name="theoryId" value="3495" />
                      <option name="title" value="Instance methods" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="4">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="172" />
                      <option name="theoryId" value="3635" />
                      <option name="title" value="Files" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="173" />
                      <option name="theoryId" value="3636" />
                      <option name="title" value="Reading files" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="177" />
                      <option name="theoryId" value="3652" />
                      <option name="title" value="Writing files" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="301" />
                      <option name="theoryId" value="4910" />
                      <option name="title" value="Random" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="5">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="197" />
                      <option name="theoryId" value="3770" />
                      <option name="title" value="What are collections" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="166" />
                      <option name="theoryId" value="3567" />
                      <option name="title" value="ArrayList" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="6">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="1" />
                      <option name="theoryId" value="3489" />
                      <option name="title" value="The main method" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="99" />
                      <option name="theoryId" value="3594" />
                      <option name="title" value="Arrays as parameters" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="111" />
                      <option name="theoryId" value="3566" />
                      <option name="title" value="Command-line arguments" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
            </map>
          </option>
          <option name="updateDate" value="0" />
          <option name="hyperskillProject">
            <HyperskillProject>
              <option name="description" value="For those who are learning a foreign language, it’s a challenge to remember new words, which is exactly what flashcards are for. Typically, flashcards show a hint (a task or a picture) on the one side and the right answer on the reverse. Flashcards can be used to remember any other sort of data: so if you want to create something useful and enhance your programming skills, this project is just right." />
              <option name="id" value="44" />
              <option name="ideFiles" value="https://stepik.org/media/attachments/lesson/208224/additional_files.json" />
              <option name="language" value="java" />
              <option name="templateBased" value="false" />
              <option name="title" value="Flashcards (Java)" />
              <option name="useIde" value="true" />
            </HyperskillProject>
          </option>
          <option name="items">
            <list>
              <FrameworkLesson>
                <option name="currentTaskIndex" value="6" />
                <option name="customPresentableName" />
                <option name="id" value="0" />
                <option name="index" value="1" />
                <option name="name" value="Flashcards (Java)" />
                <option name="updateDate" value="0" />
                <option name="unitId" value="0" />
                <option name="items">
                  <list>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Implement a program that outputs a card and its definition. You can print a card and a definition you like.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;How to submit?&lt;/h2&gt;&#10;&#10;&lt;p&gt;This stage is auto-graded. The grader will check that:&lt;/p&gt;&#10;&#10;&lt;ul&gt;&#10;    &lt;li&gt;you output 4 lines,&lt;/li&gt;&#10;    &lt;li&gt;the first line is &lt;code&gt;Card:&lt;/code&gt;,&lt;/li&gt;&#10;    &lt;li&gt;the third line is &lt;code&gt;Definition:&lt;/code&gt;.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output examples&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Card:&#10;purchase&#10;Definition:&#10;buy&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt; &lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Card:&#10;cos'(x)&#10;Definition:&#10;-sin(x)&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/44/stages/232/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="5343" />
                      <option name="index" value="1" />
                      <option name="name" value="Stage one, card one" />
                      <option name="record" value="1" />
                      <option name="status" value="Solved" />
                      <option name="files">
                        <map>
                          <entry key="src/flashcards/Main.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/Main.java" />
                                <option name="text" value="package flashcards;&#10;&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Hello World!&quot;);&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/FlashcardsTest.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/FlashcardsTest.java" />
                                <option name="text" value="import common.FlashcardsStage1Test;&#10;&#10;public class FlashcardsTest extends FlashcardsStage1Test {&#10;    // just empty class, but not abstract so it can be run&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage1Test.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage1Test.kt" />
                                <option name="text" value="package common&#10;&#10;import flashcards.Main&#10;import org.hyperskill.hstest.v5.stage.BaseStageTest&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;&#10;abstract class FlashcardsStage1Test : BaseStageTest&lt;Nothing?&gt;(Main::class.java) {&#10;&#10;    override fun generate(): List&lt;TestCase&lt;Nothing?&gt;&gt; {&#10;        return listOf(&#10;                TestCase()&#10;        )&#10;    }&#10;&#10;    override fun check(reply: String, clue: Nothing?): CheckResult {&#10;        val lines = reply.lines().filter { it.isNotEmpty() }&#10;&#10;        if (lines.size != LINE_COUNT) {&#10;            return CheckResult(&#10;                    false,&#10;                    &quot;Your program prints ${lines.size} ${lineOrLines(lines.size)}.\n&quot; +&#10;                            &quot;$LINE_COUNT lines were expected.&quot;&#10;            )&#10;        }&#10;&#10;        val firstLine = lines[0].trim()&#10;&#10;        if (firstLine != FIRST_LINE) {&#10;            return CheckResult(&#10;                    false,&#10;                    &quot;Your first line is \&quot;$firstLine\&quot; but \&quot;$FIRST_LINE\&quot; was expected.&quot;&#10;            )&#10;        }&#10;&#10;        val thirdLine = lines[2].trim()&#10;&#10;        if (thirdLine != THIRD_LINE) {&#10;            return CheckResult(&#10;                    false,&#10;                    &quot;Your third line is \&quot;$thirdLine\&quot; but \&quot;$THIRD_LINE\&quot; was expected.&quot;&#10;            )&#10;        }&#10;&#10;        return CheckResult(true)&#10;    }&#10;&#10;    private fun lineOrLines(lineCount: Int): String {&#10;        if (lineCount == 1) {&#10;            return &quot;line&quot;&#10;        }&#10;        return &quot;lines&quot;&#10;    }&#10;&#10;    companion object {&#10;        private const val LINE_COUNT = 4&#10;        private const val FIRST_LINE = &quot;Card:&quot;&#10;        private const val THIRD_LINE = &quot;Definition:&quot;&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1562385274000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Implement a custom card creation mechanism.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;How to submit?&lt;/h2&gt;&#10;&#10;&lt;p&gt;This stage is auto-graded. The grader will input 3 lines (card, definition, answer) and check that your output contains a word:&lt;/p&gt;&#10;&#10;&lt;ul&gt;&#10;    &lt;li&gt;&lt;code&gt;wrong&lt;/code&gt; if the answer isn't equal to the definition,&lt;/li&gt;&#10;    &lt;li&gt;&lt;code&gt;right&lt;/code&gt; if the answer is equal to the definition.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Input example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;a purring animal&#10;cat&#10;cat&#10;&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Your answer is right!&#10;&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Input example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;a barking animal&#10;dog&#10;cat&#10;&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Your answer is wrong...&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/44/stages/233/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="5344" />
                      <option name="index" value="2" />
                      <option name="name" value="What’s on the card?" />
                      <option name="record" value="2" />
                      <option name="status" value="Solved" />
                      <option name="files">
                        <map>
                          <entry key="test/FlashcardsTest.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/FlashcardsTest.java" />
                                <option name="text" value="import common.FlashcardsStage2Test;&#10;&#10;public class FlashcardsTest extends FlashcardsStage2Test {&#10;    // just empty class, but not abstract so it can be run&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage2Test.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage2Test.kt" />
                                <option name="text" value="package common&#10;&#10;import flashcards.Main&#10;&#10;import org.hyperskill.hstest.v5.stage.BaseStageTest&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;import common.FlashcardsStage2Answer.RIGHT&#10;import common.FlashcardsStage2Answer.WRONG&#10;&#10;data class FlashcardsStage2Clue(&#10;        val consoleInput: String,&#10;        val answer: FlashcardsStage2Answer,&#10;        val revealTest: Boolean = false&#10;)&#10;&#10;enum class FlashcardsStage2Answer(val word: String) {&#10;    RIGHT(&quot;right&quot;),&#10;    WRONG(&quot;wrong&quot;);&#10;}&#10;&#10;abstract class FlashcardsStage2Test : BaseStageTest&lt;FlashcardsStage2Clue&gt;(Main::class.java) {&#10;&#10;    override fun generate(): List&lt;TestCase&lt;FlashcardsStage2Clue&gt;&gt; {&#10;        return listOf(&#10;                createTestCase(&quot;a purring animal\ncat\ncat\n&quot;, RIGHT, true),&#10;                createTestCase(&quot;a purring animal\ncat\n????\n&quot;, WRONG, true),&#10;                createTestCase(&quot;a barking animal\ndog\ncat\n&quot;, WRONG),&#10;                createTestCase(&quot;a barking animal\ndog\ndog\n&quot;, RIGHT)&#10;        )&#10;    }&#10;&#10;    override fun check(reply: String, clue: FlashcardsStage2Clue): CheckResult {&#10;        val words = reply.lowerWords()&#10;&#10;        val hasRight = RIGHT.word.toLowerCase() in words&#10;        val hasWrong = WRONG.word.toLowerCase() in words&#10;&#10;        if ((hasRight || !hasWrong) &amp;&amp; clue.answer == WRONG) {&#10;            return if (clue.revealTest) {&#10;                CheckResult(&#10;                        false,&#10;                        revealRawTest(clue.consoleInput, reply) + &quot;Expected the \&quot;${WRONG.word}\&quot; word.&quot;&#10;                )&#10;            } else {&#10;                CheckResult(false)&#10;            }&#10;        }&#10;&#10;        if ((hasWrong || !hasRight) &amp;&amp; clue.answer == RIGHT) {&#10;            return if (clue.revealTest) {&#10;                CheckResult(&#10;                        false,&#10;                        revealRawTest(clue.consoleInput, reply) + &quot;Expected the \&quot;${RIGHT.word}\&quot; word.&quot;&#10;                )&#10;            } else {&#10;                CheckResult(false)&#10;            }&#10;        }&#10;&#10;        return CheckResult(true)&#10;    }&#10;&#10;    companion object {&#10;        private fun createTestCase(&#10;                consoleInput: String,&#10;                answer: FlashcardsStage2Answer,&#10;                revealTest: Boolean = false&#10;        ): TestCase&lt;FlashcardsStage2Clue&gt; {&#10;            return TestCase&lt;FlashcardsStage2Clue&gt;()&#10;                    .setInput(consoleInput)&#10;                    .setAttach(FlashcardsStage2Clue(consoleInput, answer, revealTest))&#10;        }&#10;    }&#10;}&#10;&#10;fun revealRawTest(consoleInput: String, reply: String): String {&#10;    return &quot;Input:\n$consoleInput\nYour output:\n$reply\n\n&quot;&#10;}&#10;&#10;fun String.lowerWords(): Set&lt;String&gt; {&#10;    val lowerReply = this.trim().toLowerCase()&#10;&#10;    val onlyLetters = lowerReply.map { if (it.isLetter()) it else ' ' }.joinToString(&quot;&quot;)&#10;&#10;    return onlyLetters.split(&quot; &quot;).filter { it.isNotEmpty() }.toSet()&#10;}&#10;&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/Main.java" />
                                <option name="text" value="package flashcards;&#10;&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Hello World!&quot;);&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1562385274000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Implement a working application now! Add support for addition of multiple cards. Then ask the user to answer all the definitions.&lt;/p&gt;&#10;&#10;&lt;p&gt;You can follow the algorithm. First, ask the user to enter the desired number of cards. Then create two string arrays (&lt;code&gt;String[]&lt;/code&gt;): &lt;code&gt;cards&lt;/code&gt; and &lt;code&gt;definitions&lt;/code&gt;. Process all entered cards and save the i-th card to &lt;code&gt;cards[i]&lt;/code&gt; and &lt;code&gt;definitions[i]&lt;/code&gt;. Finally iterate over saved cards and ask the user to answer.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Console example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Input the number of cards:&#10;2&#10;The card #1:&#10;black&#10;The definition of the card #1:&#10;white&#10;The card #2:&#10;white&#10;The definition of the card #2:&#10;black&#10;Print the definition of &quot;black&quot;:&#10;white&#10;Correct answer. Print the definition of &quot;white&quot;:&#10;blue&#10;Wrong answer (the correct one is &quot;black&quot;).&#10;&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;Here every second line is entered by the user.&lt;/p&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/44/stages/234/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="5345" />
                      <option name="index" value="3" />
                      <option name="name" value="Make it your own" />
                      <option name="record" value="3" />
                      <option name="status" value="Solved" />
                      <option name="files">
                        <map>
                          <entry key="test/FlashcardsTest.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/FlashcardsTest.java" />
                                <option name="text" value="import common.FlashcardsStage3Test;&#10;&#10;public class FlashcardsTest extends FlashcardsStage3Test {&#10;    // just empty class, but not abstract so it can be run&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage3Test.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage3Test.kt" />
                                <option name="text" value="package common&#10;&#10;&#10;import org.hyperskill.hstest.v5.stage.BaseStageTest&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;import flashcards.Main&#10;&#10;data class FlashcardsStage3Clue(&#10;        val consoleInput: String,&#10;        val revealTest: Boolean = false&#10;)&#10;&#10;abstract class FlashcardsStage3Test : BaseStageTest&lt;FlashcardsStage3Clue&gt;(Main::class.java) {&#10;&#10;    override fun generate(): List&lt;TestCase&lt;FlashcardsStage3Clue&gt;&gt; {&#10;        return listOf(&#10;                createTestCase(&#10;                        &quot;2\n&quot; +&#10;                                &quot;black\nwhite\n&quot; +&#10;                                &quot;white\nblack\n&quot; +&#10;                                &quot;white\n&quot; +&#10;                                &quot;blue\n&quot;,&#10;                        true&#10;                ),&#10;                createTestCase(&#10;                        &quot;5\n&quot; +&#10;                                &quot;1\n1\n&quot; +&#10;                                &quot;2\n2\n&quot; +&#10;                                &quot;3\n3\n&quot; +&#10;                                &quot;4\n4\n&quot; +&#10;                                &quot;5\n5\n&quot; +&#10;                                &quot;1\n&quot; +&#10;                                &quot;2\n&quot; +&#10;                                &quot;3\n&quot; +&#10;                                &quot;4\n&quot; +&#10;                                &quot;5\n&quot;,&#10;                        true&#10;                ),&#10;                createTestCase(&#10;                        &quot;5\n&quot; +&#10;                                &quot;1\n1\n&quot; +&#10;                                &quot;2\n2\n&quot; +&#10;                                &quot;3\n3\n&quot; +&#10;                                &quot;4\n4\n&quot; +&#10;                                &quot;5\n5\n&quot; +&#10;                                &quot;5\n&quot; +&#10;                                &quot;4\n&quot; +&#10;                                &quot;3\n&quot; +&#10;                                &quot;2\n&quot; +&#10;                                &quot;1\n&quot;,&#10;                        true&#10;                ),&#10;                createTestCase(&#10;                        &quot;4\n&quot; +&#10;                                &quot;11\n21\n&quot; +&#10;                                &quot;12\n22\n&quot; +&#10;                                &quot;13\n23\n&quot; +&#10;                                &quot;14\n24\n&quot; +&#10;                                &quot;21\n&quot; +&#10;                                &quot;22\n&quot; +&#10;                                &quot;33333\n&quot; +&#10;                                &quot;24\n&quot;&#10;                ),&#10;                createTestCase(&#10;                        &quot;2\n&quot; +&#10;                                &quot;a brother of one's parent\nuncle\n&quot; +&#10;                                &quot;a part of the body where the foot and the leg meet\nankle\n&quot; +&#10;                                &quot;ankle\n&quot; +&#10;                                &quot;??\n&quot;&#10;                )&#10;        )&#10;    }&#10;&#10;    /**&#10;     * This stage is auto-graded.&#10;     *&#10;     * The grader will input 1 line with the card number.&#10;     *&#10;     * Then it will input [card number] pairs of lines (card, definition).&#10;     *&#10;     * Finally, you should ask definitions of every card:&#10;     * Ask the question with the quoted card (example: Print the definition of &quot;black&quot;).&#10;     * The grader will input an answer.&#10;     * On the next line, you should grade the question. The grade must contain &quot;correct answer&quot; if the answer is correct, otherwise, it must contain &quot;wrong answer&quot;.  If the answer is wrong, you should also write the quoted correct answer (example: wrong answer, the correct one is &quot;black&quot;).&#10;     * If there are remaining cards, ask the definition of the next one in the same line.&#10;     *&#10;     * You can output as many empty lines as you want: the grader won't see them.&#10;     *&#10;     * Please check the console example.&#10;     */&#10;    override fun check(reply: String, clue: FlashcardsStage3Clue): CheckResult {&#10;        val cards = clue.consoleInput.parseConsoleInputWithoutActions()&#10;&#10;        val inputLines = clue.consoleInput.lines().filter { it.isNotEmpty() }&#10;        val replyLines = reply.lines().filter { it.isNotEmpty() }&#10;&#10;        val questionCount = inputLines[0].toInt()&#10;&#10;        val askedCards = mutableSetOf&lt;String&gt;()&#10;&#10;        val questions = replyLines.takeLast(questionCount + 1).take(questionCount)&#10;        val answers = inputLines.takeLast(questionCount)&#10;        val grades = replyLines.takeLast(questionCount)&#10;&#10;        for (questionId in 0 until questionCount) {&#10;            val question = questions[questionId]&#10;            val answer = answers[questionId]&#10;            val grade = grades[questionId]&#10;&#10;            val hasCorrect = CORRECT.toLowerCase() in grade.toLowerCase()&#10;            val hasWrong = WRONG.toLowerCase() in grade.toLowerCase()&#10;&#10;            val card = question.substringBeforeLast('&quot;').substringAfterLast('&quot;')&#10;&#10;            askedCards.add(card)&#10;&#10;            val correctAnswer = cards.cardToDefinition[card] == answer&#10;&#10;            if (correctAnswer &amp;&amp; (hasWrong || !hasCorrect)) {&#10;                return if (clue.revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is correct.&quot;&#10;&#10;                    CheckResult(&#10;                            false,&#10;                            revealRawTest(clue.consoleInput, reply) +&#10;                                    revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    CheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; (hasCorrect || !hasWrong)) {&#10;                return if (clue.revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is wrong.&quot;&#10;&#10;                    CheckResult(&#10;                            false,&#10;                            revealRawTest(clue.consoleInput, reply) +&#10;                                    revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    CheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer) {&#10;                val suggestedDefinition = grade.substringAfter('&quot;').substringBefore('&quot;')&#10;&#10;                if (suggestedDefinition != cards.cardToDefinition[card]) {&#10;                    return if (clue.revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$suggestedDefinition\&quot; is correct but it isn't.&quot;&#10;&#10;                        CheckResult(&#10;                                false,&#10;                                revealRawTest(clue.consoleInput, reply) +&#10;                                        revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        CheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        if (askedCards.size != questionCount) {&#10;            return if (clue.revealTest) {&#10;                CheckResult(&#10;                        false,&#10;                        &quot;You haven't asked about some cards: ${cards.cardToDefinition.keys - askedCards}.&quot;&#10;                )&#10;            } else {&#10;                CheckResult(false, &quot;You haven't asked about some cards&quot;)&#10;            }&#10;        }&#10;&#10;        return CheckResult(true)&#10;    }&#10;&#10;    companion object {&#10;        private const val CORRECT = &quot;correct answer&quot;&#10;        private const val WRONG = &quot;wrong answer&quot;&#10;&#10;        private fun createTestCase(&#10;                consoleInput: String,&#10;                revealTest: Boolean = false&#10;        ): TestCase&lt;FlashcardsStage3Clue&gt; {&#10;            return TestCase&lt;FlashcardsStage3Clue&gt;()&#10;                    .setInput(consoleInput)&#10;                    .setAttach(FlashcardsStage3Clue(consoleInput, revealTest))&#10;        }&#10;    }&#10;}&#10;&#10;data class ParsedCards(&#10;        val cardToDefinition: Map&lt;String, String&gt;,&#10;        val definitionToCard: Map&lt;String, String&gt;&#10;)&#10;&#10;fun revealRawTest(consoleInput: String, reply: String): String {&#10;    return &quot;Input:\n$consoleInput\nYour output:\n$reply\n\n&quot;&#10;}&#10;&#10;fun String.parseConsoleInputWithoutActions(): ParsedCards {&#10;    val lines = this.lines()&#10;&#10;    val cardCount = lines[0].toInt()&#10;&#10;    var lastLineWithCardId = 2 * cardCount&#10;&#10;    val cardToDefinition = mutableMapOf&lt;String, String&gt;()&#10;    val definitionToCard = mutableMapOf&lt;String, String&gt;()&#10;&#10;    var lineId = 1&#10;&#10;    while (lineId &lt;= lastLineWithCardId) {&#10;        val card = lines[lineId]&#10;        val definition = lines[lineId + 1]&#10;&#10;        if (card in cardToDefinition) {&#10;            lastLineWithCardId += 1&#10;            lineId += 1&#10;        } else {&#10;            cardToDefinition[card] = definition&#10;            definitionToCard[definition] = card&#10;&#10;            lineId += 2&#10;        }&#10;    }&#10;&#10;    return ParsedCards(cardToDefinition = cardToDefinition, definitionToCard = definitionToCard)&#10;}&#10;&#10;fun revealTestWithoutActions(&#10;        questions: List&lt;String&gt;,&#10;        answers: List&lt;String&gt;,&#10;        grades: List&lt;String&gt;&#10;): String {&#10;    val count = minOf(questions.size, answers.size, grades.size)&#10;&#10;    return &quot;Questions:\n\n&quot; +&#10;            (0 until count).joinToString(&quot;\n&quot;) {&#10;                &quot;Question:\n${questions[it]}\n&quot; +&#10;                        &quot;Answer:\n${answers[it]}\n&quot; +&#10;                        &quot;Grade:\n${grades[it]}\n&quot;&#10;            } +&#10;            &quot;\n&quot;&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/Main.java" />
                                <option name="text" value="package flashcards;&#10;&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Hello World!&quot;);&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.class">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="src/flashcards/Main.class" />
                                <option name="text" value="" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1562385275000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;There is a common situation that the answer is wrong for the given card but it's correct for another card. Let's consider situations like this.&lt;/p&gt;&#10;&#10;&lt;p&gt;Remove array-based storage. Use two maps (&lt;code&gt;Map&amp;lt;String, String&amp;gt;&lt;/code&gt;): &lt;code&gt;cardToDefinition&lt;/code&gt; and &lt;code&gt;definitionToCard&lt;/code&gt;. If the definition is wrong but it is presented in &lt;code&gt;definitionToCard&lt;/code&gt;, output the original card.&lt;/p&gt;&#10;&#10;&lt;p&gt;When the user tries to add a duplicated card or a definition, forbid it. For now you are able to implement this without a &lt;code&gt;try catch&lt;/code&gt; construction. Use the rule: if you can avoid exception-based logic, avoid it!&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Console example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Input the number of cards:&#10;2&#10;The card #1:&#10;a brother of one's parent&#10;The definition of the card #1:&#10;uncle&#10;The card #2:&#10;a part of the body where the foot and the leg meet&#10;The definition of the card #2:&#10;ankle&#10;Print the definition of &quot;a brother of one's parent&quot;:&#10;ankle&#10;Wrong answer (the correct one is &quot;uncle&quot;, you've just written a definition of &quot;a part of the body where the foot and the leg meet&quot; card). Print the definition of &quot;a part of the body where the foot and the leg meet&quot;:&#10;???&#10;Wrong answer (the correct one is &quot;ankle&quot;).&#10;&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;Here every second line is entered by the user.&lt;/p&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/44/stages/235/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="5346" />
                      <option name="index" value="4" />
                      <option name="name" value="A good stack" />
                      <option name="record" value="4" />
                      <option name="status" value="Solved" />
                      <option name="files">
                        <map>
                          <entry key="test/FlashcardsTest.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/FlashcardsTest.java" />
                                <option name="text" value="import common.FlashcardsStage4Test;&#10;&#10;public class FlashcardsTest extends FlashcardsStage4Test {&#10;    // just empty class, but not abstract so it can be run&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage4Test.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage4Test.kt" />
                                <option name="text" value="package common&#10;&#10;import org.hyperskill.hstest.v5.stage.BaseStageTest&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;import flashcards.Main&#10;&#10;data class FlashcardsStage4Clue(&#10;        val consoleInput: String,&#10;        val revealTest: Boolean = false&#10;)&#10;&#10;abstract class FlashcardsStage4Test : BaseStageTest&lt;FlashcardsStage4Clue&gt;(Main::class.java) {&#10;&#10;    override fun generate(): List&lt;TestCase&lt;FlashcardsStage4Clue&gt;&gt; {&#10;        return listOf(&#10;                createTestCase(&#10;                        &quot;2\n&quot; +&#10;                                &quot;a brother of one's parent\nuncle\n&quot; +&#10;                                &quot;a part of the body where the foot and the leg meet\nankle\n&quot; +&#10;                                &quot;ankle\n&quot; +&#10;                                &quot;??\n&quot;,&#10;                        true&#10;                ),&#10;                createTestCase(&#10;                        &quot;4\n&quot; +&#10;                                &quot;11\n21\n&quot; +&#10;                                &quot;12\n22\n&quot; +&#10;                                &quot;12\n&quot; +&#10;                                &quot;13\n23\n&quot; +&#10;                                &quot;14\n24\n&quot; +&#10;                                &quot;21\n&quot; +&#10;                                &quot;22\n&quot; +&#10;                                &quot;33333\n&quot; +&#10;                                &quot;24\n&quot;,&#10;                        true&#10;                ),&#10;                createTestCase(&#10;                        &quot;2\n&quot; +&#10;                                &quot;black\nwhite\n&quot; +&#10;                                &quot;black\n&quot; +&#10;                                &quot;black\n&quot; +&#10;                                &quot;white\nblack\n&quot; +&#10;                                &quot;white\n&quot; +&#10;                                &quot;blue\n&quot;&#10;                ),&#10;                createTestCase(&#10;                        &quot;2\n&quot; +&#10;                                &quot;black\nwhite\n&quot; +&#10;                                &quot;white\nblack\n&quot; +&#10;                                &quot;white\n&quot; +&#10;                                &quot;blue\n&quot;&#10;                ),&#10;                createTestCase(&#10;                        &quot;5\n&quot; +&#10;                                &quot;1\n1\n&quot; +&#10;                                &quot;2\n2\n&quot; +&#10;                                &quot;3\n3\n&quot; +&#10;                                &quot;4\n4\n&quot; +&#10;                                &quot;5\n5\n&quot; +&#10;                                &quot;1\n&quot; +&#10;                                &quot;2\n&quot; +&#10;                                &quot;3\n&quot; +&#10;                                &quot;4\n&quot; +&#10;                                &quot;5\n&quot;&#10;                ),&#10;                createTestCase(&#10;                        &quot;5\n&quot; +&#10;                                &quot;1\n1\n&quot; +&#10;                                &quot;2\n2\n&quot; +&#10;                                &quot;3\n3\n&quot; +&#10;                                &quot;4\n4\n&quot; +&#10;                                &quot;5\n5\n&quot; +&#10;                                &quot;5\n&quot; +&#10;                                &quot;4\n&quot; +&#10;                                &quot;3\n&quot; +&#10;                                &quot;2\n&quot; +&#10;                                &quot;1\n&quot;&#10;                ),&#10;                createTestCase(&#10;                        &quot;4\n&quot; +&#10;                                &quot;11\n21\n&quot; +&#10;                                &quot;12\n22\n&quot; +&#10;                                &quot;13\n23\n&quot; +&#10;                                &quot;14\n24\n&quot; +&#10;                                &quot;21\n&quot; +&#10;                                &quot;22\n&quot; +&#10;                                &quot;33333\n&quot; +&#10;                                &quot;24\n&quot;&#10;                )&#10;        )&#10;    }&#10;&#10;    /**&#10;     * This stage is auto-graded.&#10;     *&#10;     * The behaviour is almost the same as the one in the previous stage.&#10;     *&#10;     * You should print the quoted original card after the correct one (example: the correct one is &quot;uncle&quot;, you've just written a definition of &quot;a part of the body where the foot and the leg meet&quot; card).&#10;     *&#10;     * Also, the grader can input already existing cards. You should ask for the card until the unique card is inputted.&#10;     *&#10;     * Please check the console example.&#10;     */&#10;    override fun check(reply: String, clue: FlashcardsStage4Clue): CheckResult {&#10;        val cards = clue.consoleInput.parseConsoleInputWithoutActions()&#10;&#10;        val inputLines = clue.consoleInput.lines().filter { it.isNotEmpty() }&#10;        val replyLines = reply.lines().filter { it.isNotEmpty() }&#10;&#10;        val questionCount = inputLines[0].toInt()&#10;&#10;        val askedCards = mutableSetOf&lt;String&gt;()&#10;&#10;        val questions = replyLines.takeLast(questionCount + 1).take(questionCount)&#10;        val answers = inputLines.takeLast(questionCount)&#10;        val grades = replyLines.takeLast(questionCount)&#10;&#10;        for (questionId in 0 until questionCount) {&#10;            val question = questions[questionId]&#10;            val answer = answers[questionId]&#10;            val grade = grades[questionId]&#10;&#10;            val hasCorrect = CORRECT.toLowerCase() in grade.toLowerCase()&#10;            val hasWrong = WRONG.toLowerCase() in grade.toLowerCase()&#10;&#10;            val card = question.substringBeforeLast('&quot;').substringAfterLast('&quot;')&#10;&#10;            askedCards.add(card)&#10;&#10;            val correctAnswer = cards.cardToDefinition[card] == answer&#10;&#10;            if (correctAnswer &amp;&amp; (hasWrong || !hasCorrect)) {&#10;                return if (clue.revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is correct.&quot;&#10;&#10;                    CheckResult(&#10;                            false,&#10;                            revealRawTest(clue.consoleInput, reply) +&#10;                                    revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    CheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; (hasCorrect || !hasWrong)) {&#10;                return if (clue.revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is wrong.&quot;&#10;&#10;                    CheckResult(&#10;                            false,&#10;                            revealRawTest(clue.consoleInput, reply) +&#10;                                    revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    CheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer) {&#10;                val suggestedDefinition = grade.substringAfter('&quot;').substringBefore('&quot;')&#10;&#10;                if (suggestedDefinition != cards.cardToDefinition[card]) {&#10;                    return if (clue.revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$suggestedDefinition\&quot; is correct but it isn't.&quot;&#10;&#10;                        CheckResult(&#10;                                false,&#10;                                revealRawTest(clue.consoleInput, reply) +&#10;                                        revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        CheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; answer in cards.definitionToCard) {&#10;                val originalCard = grade&#10;                        .substringAfter('&quot;')&#10;                        .substringAfter('&quot;')&#10;                        .substringAfter('&quot;')&#10;                        .substringBefore('&quot;')&#10;&#10;                if (originalCard != cards.definitionToCard[answer]) {&#10;                    return if (clue.revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$originalCard\&quot; card is the original one but it isn't.&quot;&#10;&#10;                        CheckResult(&#10;                                false,&#10;                                revealRawTest(clue.consoleInput, reply) +&#10;                                        revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        CheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        if (askedCards.size != questionCount) {&#10;            return if (clue.revealTest) {&#10;                CheckResult(&#10;                        false,&#10;                        &quot;You haven't asked about some cards: ${cards.cardToDefinition.keys - askedCards}.&quot;&#10;                )&#10;            } else {&#10;                CheckResult(false, &quot;You haven't asked about some cards&quot;)&#10;            }&#10;        }&#10;&#10;        return CheckResult(true)&#10;    }&#10;&#10;    companion object {&#10;        private const val CORRECT = &quot;correct answer&quot;&#10;        private const val WRONG = &quot;wrong answer&quot;&#10;&#10;        private fun createTestCase(&#10;                consoleInput: String,&#10;                revealTest: Boolean = false&#10;        ): TestCase&lt;FlashcardsStage4Clue&gt; {&#10;            return TestCase&lt;FlashcardsStage4Clue&gt;()&#10;                    .setInput(consoleInput)&#10;                    .setAttach(FlashcardsStage4Clue(consoleInput, revealTest))&#10;        }&#10;    }&#10;}&#10;&#10;&#10;data class ParsedCards(&#10;        val cardToDefinition: Map&lt;String, String&gt;,&#10;        val definitionToCard: Map&lt;String, String&gt;&#10;)&#10;&#10;fun revealRawTest(consoleInput: String, reply: String): String {&#10;    return &quot;Input:\n$consoleInput\nYour output:\n$reply\n\n&quot;&#10;}&#10;&#10;fun String.parseConsoleInputWithoutActions(): ParsedCards {&#10;    val lines = this.lines()&#10;&#10;    val cardCount = lines[0].toInt()&#10;&#10;    var lastLineWithCardId = 2 * cardCount&#10;&#10;    val cardToDefinition = mutableMapOf&lt;String, String&gt;()&#10;    val definitionToCard = mutableMapOf&lt;String, String&gt;()&#10;&#10;    var lineId = 1&#10;&#10;    while (lineId &lt;= lastLineWithCardId) {&#10;        val card = lines[lineId]&#10;        val definition = lines[lineId + 1]&#10;&#10;        if (card in cardToDefinition) {&#10;            lastLineWithCardId += 1&#10;            lineId += 1&#10;        } else {&#10;            cardToDefinition[card] = definition&#10;            definitionToCard[definition] = card&#10;&#10;            lineId += 2&#10;        }&#10;    }&#10;&#10;    return ParsedCards(cardToDefinition = cardToDefinition, definitionToCard = definitionToCard)&#10;}&#10;&#10;fun revealTestWithoutActions(&#10;        questions: List&lt;String&gt;,&#10;        answers: List&lt;String&gt;,&#10;        grades: List&lt;String&gt;&#10;): String {&#10;    val count = minOf(questions.size, answers.size, grades.size)&#10;&#10;    return &quot;Questions:\n\n&quot; +&#10;            (0 until count).joinToString(&quot;\n&quot;) {&#10;                &quot;Question:\n${questions[it]}\n&quot; +&#10;                        &quot;Answer:\n${answers[it]}\n&quot; +&#10;                        &quot;Grade:\n${grades[it]}\n&quot;&#10;            } +&#10;            &quot;\n&quot;&#10;}&#10;&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/Main.java" />
                                <option name="text" value="package flashcards;&#10;&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Hello World!&quot;);&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.class">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="src/flashcards/Main.class" />
                                <option name="text" value="&#10;  // IntelliJ API Decompiler stub source generated from a class file&#10;  // Implementation of methods is not available&#10;&#10;package corrupted_class_files;&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1562385275000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Improve the application’s interactivity. Ask the user for action and do it.&lt;br&gt;&#10;&lt;br&gt;&#10;Support these actions:&lt;/p&gt;&#10;&#10;&lt;ul&gt;&#10;&#9;&lt;li&gt;add a card: &lt;code&gt;add&lt;/code&gt;,&lt;/li&gt;&#10;&#9;&lt;li&gt;remove a card: &lt;code&gt;remove&lt;/code&gt;,&lt;/li&gt;&#10;&#9;&lt;li&gt;load cards from file (&quot;deserialization&quot;): &lt;code&gt;import&lt;/code&gt;,&lt;/li&gt;&#10;&#9;&lt;li&gt;save cards to file (&quot;serialization&quot;): &lt;code&gt;export&lt;/code&gt;,&lt;/li&gt;&#10;&#9;&lt;li&gt;ask for a definition of some random cards: &lt;code&gt;ask&lt;/code&gt;,&lt;/li&gt;&#10;&#9;&lt;li&gt;exit the program: &lt;code&gt;exit&lt;/code&gt;.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&#10;&lt;p&gt;You can use the following file format. The file consists of pairs of lines. The first line of each pair is a card, and the second line is a definition of the card.&lt;/p&gt;&#10;&#10;&lt;p&gt;In this stage, if you try to add a new card with an already existing definition you should delete the old card and save the new card. This also applies when importing cards.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Console example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Input the action (add, remove, import, export, ask, exit):&#10;add&#10;The card:&#10;Great Britain&#10;The definition of the card:&#10;London&#10;The pair (&quot;Great Britain&quot;:&quot;London&quot;) is added.&#10;&#10;Input the action (add, remove, import, export, ask, exit):&#10;remove&#10;The card:&#10;Wakanda&#10;Can't remove &quot;Wakanda&quot;: there is no such card.&#10;&#10;Input the action (add, remove, import, export, ask, exit):&#10;import&#10;File name:&#10;capitals.txt&#10;28 cards have been loaded.&#10;&#10;Input the action (add, remove, import, export, ask, exit):&#10;ask&#10;How many times to ask?&#10;1&#10;Print the definition of &quot;Russia&quot;:&#10;Moscow&#10;Correct answer.&#10;&#10;Input the action (add, remove, import, export, ask, exit):&#10;export&#10;File name:&#10;capitalsNew.txt&#10;29 cards have been saved.&#10;&#10;Input the action (add, remove, import, export, ask, exit):&#10;exit&#10;Bye bye!&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/44/stages/236/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="5347" />
                      <option name="index" value="5" />
                      <option name="name" value="Menu, please!" />
                      <option name="record" value="5" />
                      <option name="status" value="Failed" />
                      <option name="files">
                        <map>
                          <entry key="test/FlashcardsTest.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/FlashcardsTest.java" />
                                <option name="text" value="import common.FlashcardsStage5Test;&#10;&#10;public class FlashcardsTest extends FlashcardsStage5Test {&#10;    // just empty class, but not abstract so it can be run&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage5Test.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage5Test.kt" />
                                <option name="text" value="package common&#10;&#10;import org.hyperskill.hstest.v5.stage.BaseStageTest&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;import flashcards.Main&#10;&#10;abstract class FlashcardsStage5Test : BaseStageTest&lt;FlashcardsStage567Clue&gt;(Main::class.java) {&#10;&#10;    override fun generate(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;        return createStage5Tests() + generateOldTests()&#10;    }&#10;&#10;    /**&#10;     * This stage is auto-graded.&#10;     *&#10;     * The grader skips empty lines.&#10;     *&#10;     * Every action must start with words &quot;input the action&quot;.&#10;     *&#10;     * The behaviour of &quot;ask&quot; action is the same as the behaviour of the previous stage.&#10;     *&#10;     * Please check the console example.&#10;     */&#10;    override fun check(reply: String, clue: FlashcardsStage567Clue): CheckResult {&#10;        return checkStage567(reply, clue)&#10;    }&#10;&#10;    companion object {&#10;        fun createStage5Tests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;            // TODO: how to remove files? Now at least rewrite at the first test:&#10;&#10;            return listOf(&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Export(&quot;capitals.txt&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Remove(&quot;Wakanda&quot;),&#10;                                    Import(&quot;capitals.txt&quot;, 0),&#10;                                    Ask(listOf(&quot;London&quot;)),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 1),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 1),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 3),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 3),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 4),&#10;                                    Exit()&#10;                            ),&#10;                            false&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Add(&quot;London&quot;, &quot;Big Ben&quot;),&#10;                                    Remove(&quot;London&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 4),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Add(&quot;London&quot;, &quot;Big Ben&quot;),&#10;                                    Remove(&quot;London&quot;),&#10;                                    Remove(&quot;Russia&quot;),&#10;                                    Remove(&quot;Japan&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 2),&#10;                                    Exit()&#10;                            ),&#10;                            false&#10;                    )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun revealRawTest(consoleInput: String, reply: String): String {&#10;    return &quot;Input:\n$consoleInput\nYour output:\n$reply\n\n&quot;&#10;}&#10;&#10;fun revealTestWithoutActions(&#10;        questions: List&lt;String&gt;,&#10;        answers: List&lt;String&gt;,&#10;        grades: List&lt;String&gt;&#10;): String {&#10;    val count = minOf(questions.size, answers.size, grades.size)&#10;&#10;    return &quot;Questions:\n\n&quot; +&#10;            (0 until count).joinToString(&quot;\n&quot;) {&#10;                &quot;Question:\n${questions[it]}\n&quot; +&#10;                        &quot;Answer:\n${answers[it]}\n&quot; +&#10;                        &quot;Grade:\n${grades[it]}\n&quot;&#10;            } +&#10;            &quot;\n&quot;&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage567TestCommon.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage567TestCommon.kt" />
                                <option name="text" value="package common&#10;&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;&#10;fun checkStage567(reply: String, clue: FlashcardsStage567Clue): CheckResult {&#10;    val actionLines = splitReplyToActions(reply)&#10;&#10;    if (actionLines.size != clue.actions.size) {&#10;        val feedback = &quot;${actionLines.size} are found but ${clue.actions.size} actions have been inputted.&quot;&#10;&#10;        return if (clue.revealTest) {&#10;            CheckResult(false, revealRawTest(clue.consoleInput, reply) + feedback)&#10;        } else {&#10;            CheckResult(false, feedback)&#10;        }&#10;    }&#10;&#10;    val cards = Cards()&#10;&#10;    val checks = actionLines&#10;            .zip(clue.actions)&#10;            .map { (lines, action) -&gt; action.check(clue.revealTest, cards, lines) }&#10;&#10;    val firstUnsuccessful = checks.firstOrNull { !it.isCorrect }&#10;&#10;    if (firstUnsuccessful != null) {&#10;        return if (clue.revealTest) {&#10;            CheckResult(false, revealRawTest(clue.consoleInput, reply) + firstUnsuccessful.feedback)&#10;        } else {&#10;            CheckResult(false, firstUnsuccessful.feedback)&#10;        }&#10;    }&#10;&#10;    return CheckResult(true)&#10;}&#10;&#10;class FlashcardsStage567Clue(&#10;        val consoleInput: String,&#10;        val actions: List&lt;Action&gt;,&#10;        val revealTest: Boolean&#10;)&#10;&#10;fun createFlashcardsStage567TestCase(&#10;        actions: List&lt;Action&gt;,&#10;        revealTest: Boolean = false,&#10;        vararg args: String&#10;): TestCase&lt;FlashcardsStage567Clue&gt; {&#10;    val consoleInput = actions.flatMap { it.generateInput() }.joinToString(&quot;\n&quot;)&#10;&#10;    return TestCase&lt;FlashcardsStage567Clue&gt;()&#10;            .setInput(consoleInput)&#10;            .setAttach(FlashcardsStage567Clue(consoleInput, actions, revealTest))&#10;            .addArguments(*args)&#10;}&#10;&#10;fun splitReplyToActions(reply: String): List&lt;List&lt;String&gt;&gt; {&#10;    val answer = mutableListOf&lt;List&lt;String&gt;&gt;()&#10;&#10;    var lines = reply.lines().filter { it.isNotEmpty() }&#10;&#10;    while (lines.isNotEmpty()) {&#10;        val lastAction = lines.takeLastWhile { &quot;input the action&quot; !in it.toLowerCase() }&#10;&#10;        if (lines.size &gt; lastAction.size) {&#10;            answer.add(lastAction)&#10;            lines = lines.dropLast(lastAction.size + 1)&#10;        } else {&#10;            break  // if the first action doesn't contain &quot;input the action&quot; then it's not an action&#10;            // for example, it can be info about the program or lines about run arguments&#10;        }&#10;    }&#10;&#10;    return answer.reversed()&#10;}&#10;&#10;class Cards(&#10;        val cardToDefinition: MutableMap&lt;String, String&gt; = mutableMapOf(),&#10;        val definitionToCard: MutableMap&lt;String, String&gt; = mutableMapOf()&#10;)&#10;&#10;fun generateOldTests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;    return listOf(&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;a brother of one's parent&quot;, &quot;uncle&quot;),&#10;                            Add(&quot;a part of the body where the foot and the leg meet&quot;, &quot;ankle&quot;),&#10;                            Ask(listOf(&quot;ankle&quot;, &quot;??&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    true&#10;            ),&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;black&quot;, &quot;white&quot;),&#10;                            Add(&quot;black&quot;, &quot;pink&quot;),&#10;                            Add(&quot;black&quot;, &quot;yellow&quot;),&#10;                            Ask(listOf(&quot;white&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    true&#10;            ),&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;11&quot;, &quot;21&quot;),&#10;                            Add(&quot;12&quot;, &quot;22&quot;),&#10;                            Add(&quot;12&quot;, &quot;222&quot;),&#10;                            Ask(listOf(&quot;22&quot;, &quot;22&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    false&#10;            )&#10;    )&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage567TestCommonActions.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage567TestCommonActions.kt" />
                                <option name="text" value="package common&#10;&#10;import java.io.File&#10;&#10;open class ActionCheckResult(val isCorrect: Boolean, val feedback: String? = null)&#10;&#10;sealed class Action {&#10;    abstract fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult&#10;&#10;    abstract fun generateInput(): List&lt;String&gt;&#10;}&#10;&#10;class Add(private val card: String, private val definition: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 3) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 3 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 3 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val lastLine = replyLines.last()&#10;        val lastLineMeansAddition = '(' in lastLine&#10;&#10;        val cardAlreadyExists = card in cards.cardToDefinition&#10;&#10;        if (lastLineMeansAddition &amp;&amp; cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you add the card but &quot; +&#10;                                &quot;the card already exists.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you add the card which already exists.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!lastLineMeansAddition &amp;&amp; !cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you don't add the card but &quot; +&#10;                                &quot;the card doesn't already exist so you should.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't add the card which doesn't already exist.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!cardAlreadyExists) {&#10;            cards.cardToDefinition[card] = definition&#10;            cards.definitionToCard[definition] = card&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, card, definition)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;add&quot;&#10;    }&#10;}&#10;&#10;class Remove(private val card: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val lastLine = replyLines.last()&#10;        val lastLineMeansDeletion = &quot;can't remove&quot; !in lastLine.toLowerCase()&#10;&#10;        val cardAlreadyExists = card in cards.cardToDefinition&#10;&#10;        if (lastLineMeansDeletion &amp;&amp; !cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you remove the card but &quot; +&#10;                                &quot;the card doesn't already exist.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you remove the card which doesn't already exist.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!lastLineMeansDeletion &amp;&amp; cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you don't remove the card but &quot; +&#10;                                &quot;the card already exists so you should.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't remove the card which already exists.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (cardAlreadyExists) {&#10;            val definition = cards.cardToDefinition[card]&#10;            cards.cardToDefinition.remove(card)&#10;            cards.definitionToCard.remove(definition)&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, card)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;remove&quot;&#10;    }&#10;}&#10;&#10;class Import(private val fileName: String, private val expectedCardCount: Int) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCounts = replyLines&#10;                .last()&#10;                .split(&quot; &quot;)&#10;                .filter { it.isNotEmpty() &amp;&amp; it.all { c -&gt; c.isDigit() } }&#10;&#10;        if (cardCounts.size != 1) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 number.\n&quot; +&#10;                                &quot;Line: ${replyLines.last()}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 number.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCount = cardCounts.first().toInt()&#10;&#10;        if (cardCount != expectedCardCount) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you import an unexpected ($cardCount) amount of cards. &quot; +&#10;                                &quot;Expected: $expectedCardCount.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you import an unexpected amount of cards.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, fileName)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;import&quot;&#10;    }&#10;}&#10;&#10;class Export(private val fileName: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCounts = replyLines&#10;                .last()&#10;                .split(&quot; &quot;)&#10;                .filter { it.isNotEmpty() &amp;&amp; it.all { c -&gt; c.isDigit() } }&#10;&#10;        if (cardCounts.isEmpty()) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.\n&quot; +&#10;                                &quot;Line: ${replyLines.last()}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val file = File(fileName)&#10;&#10;        if (!file.exists()) {&#10;            ActionCheckResult(&#10;                    false,&#10;                    &quot;Action \&quot;$ACTION_NAME\&quot;: you don't create the file.&quot;&#10;            )&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, fileName)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;export&quot;&#10;    }&#10;}&#10;&#10;class Exit : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;exit&quot;&#10;    }&#10;}&#10;&#10;class Ask(private val answers: List&lt;String&gt;) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        val questionCount = answers.size&#10;&#10;        val questions = replyLines.takeLast(questionCount + 1).take(questionCount)&#10;        val grades = replyLines.takeLast(questionCount)&#10;&#10;        for (questionId in 0 until questionCount) {&#10;            val question = questions[questionId]&#10;            val answer = answers[questionId]&#10;            val grade = grades[questionId]&#10;&#10;            val hasCorrect = CORRECT.toLowerCase() in grade.toLowerCase()&#10;            val hasWrong = WRONG.toLowerCase() in grade.toLowerCase()&#10;&#10;            val card = question.substringBeforeLast('&quot;').substringAfterLast('&quot;')&#10;&#10;            val correctAnswer = cards.cardToDefinition[card] == answer&#10;&#10;            if (correctAnswer &amp;&amp; (hasWrong || !hasCorrect)) {&#10;                return if (revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is correct.&quot;&#10;&#10;                    ActionCheckResult(&#10;                            false,&#10;                            revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    ActionCheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; (hasCorrect || !hasWrong)) {&#10;                return if (revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is wrong.&quot;&#10;&#10;                    ActionCheckResult(&#10;                            false,&#10;                            revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    ActionCheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer) {&#10;                val suggestedDefinition = grade.substringAfter('&quot;').substringBefore('&quot;')&#10;&#10;                if (suggestedDefinition != cards.cardToDefinition[card]) {&#10;                    return if (revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$suggestedDefinition\&quot; is correct but it isn't.&quot;&#10;&#10;                        ActionCheckResult(&#10;                                false,&#10;                                revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        ActionCheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; answer in cards.definitionToCard) {&#10;                val originalCard = grade&#10;                        .substringAfter('&quot;')&#10;                        .substringAfter('&quot;')&#10;                        .substringAfter('&quot;')&#10;                        .substringBefore('&quot;')&#10;&#10;                if (originalCard != cards.definitionToCard[answer]) {&#10;                    return if (revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$originalCard\&quot; card is the original one but it isn't.&quot;&#10;&#10;                        ActionCheckResult(&#10;                                false,&#10;                                revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        ActionCheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, answers.size.toString()) + answers&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;ask&quot;&#10;&#10;        private const val CORRECT = &quot;correct answer&quot;&#10;        private const val WRONG = &quot;wrong answer&quot;&#10;    }&#10;}&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/Main.java" />
                                <option name="text" value="package flashcards;&#10;&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Hello World!&quot;);&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.class">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="src/flashcards/Main.class" />
                                <option name="text" value="&#10;  // IntelliJ API Decompiler stub source generated from a class file&#10;  // Implementation of methods is not available&#10;&#10;package corrupted_class_files;&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/FlashCard.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/FlashCard.java" />
                                <option name="text" value="" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1562385275000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Add some statistics features. We suggest you implement the following:&lt;/p&gt;&#10;&#10;&lt;ul&gt;&#10;  &lt;li&gt;Action &lt;code&gt;log&lt;/code&gt; saves the application log to the given file. For example, the program uses &lt;code&gt;ArrayList&lt;/code&gt; to store all lines that have been input or output in the console and then saves them to the file.&lt;/li&gt;&#10;  &lt;li&gt;Action &lt;code&gt;hardest card&lt;/code&gt; prints the card that has the most mistakes. You can store the mistake count in &lt;code&gt;Map&amp;lt;String, Integer&amp;gt;&lt;/code&gt;. Also you should implement &lt;code&gt;reset stats&lt;/code&gt; action (it erases the mistake counts for all cards) and update serialization/deserialization to store sets of three lines (card, definition, mistakes) instead of pairs (card, definition).  &lt;/li&gt;&#10;&lt;/ul&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Console example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):&#10;ask&#10;How many times to ask?&#10;1&#10;Print the definition of &quot;Russia&quot;:&#10;Paris&#10;Wrong answer (the correct one is &quot;Moscow&quot;, you've just written a definition of &quot;France&quot; card).&#10;&#10;Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):&#10;log&#10;File name:&#10;todayLog.txt&#10;The log has been saved.&#10;&#10;Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):&#10;hardest card&#10;The hardest card is &quot;Russia&quot;. You have 10 errors answering it.&#10;&#10;Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):&#10;exit&#10;Bye bye!&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/44/stages/237/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="5348" />
                      <option name="index" value="6" />
                      <option name="name" value="Statistics" />
                      <option name="record" value="6" />
                      <option name="status" value="Solved" />
                      <option name="files">
                        <map>
                          <entry key="test/FlashcardsTest.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/FlashcardsTest.java" />
                                <option name="text" value="import common.FlashcardsStage6Test;&#10;&#10;public class FlashcardsTest extends FlashcardsStage6Test {&#10;    // just empty class, but not abstract so it can be run&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage6Test.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage6Test.kt" />
                                <option name="text" value="package common&#10;&#10;import org.hyperskill.hstest.v5.stage.BaseStageTest&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;import flashcards.Main&#10;&#10;abstract class FlashcardsStage6Test : BaseStageTest&lt;FlashcardsStage567Clue&gt;(Main::class.java) {&#10;&#10;    override fun generate(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;        return createStage6Tests() + createStage5Tests() + generateOldTests()&#10;    }&#10;&#10;    /**&#10;     * This stage is auto-graded.&#10;     *&#10;     * The grader skips empty lines.&#10;     *&#10;     * Every action must start with words &quot;input the action&quot;.&#10;     *&#10;     * The behaviour of &quot;ask&quot; action is the same as the behaviour of the previous stage.&#10;     *&#10;     * Please check the console example.&#10;     */&#10;    override fun check(reply: String, clue: FlashcardsStage567Clue): CheckResult {&#10;        return checkStage567(reply, clue)&#10;    }&#10;&#10;    companion object {&#10;&#10;        fun createStage5Tests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;            // TODO: how to remove files? Now at least rewrite at the first test:&#10;&#10;            return listOf(&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Export(&quot;capitals.txt&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Remove(&quot;Wakanda&quot;),&#10;                                    Import(&quot;capitals.txt&quot;, 0),&#10;                                    Ask(listOf(&quot;London&quot;)),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 1),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 1),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 3),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 3),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 4),&#10;                                    Exit()&#10;                            ),&#10;                            false&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Add(&quot;London&quot;, &quot;Big Ben&quot;),&#10;                                    Remove(&quot;London&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 4),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Add(&quot;London&quot;, &quot;Big Ben&quot;),&#10;                                    Remove(&quot;London&quot;),&#10;                                    Remove(&quot;Russia&quot;),&#10;                                    Remove(&quot;Japan&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 2),&#10;                                    Exit()&#10;                            ),&#10;                            false&#10;                    )&#10;            )&#10;        }&#10;&#10;&#10;        fun createStage6Tests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;            // TODO: how to remove files? Now at least rewrite at the first test:&#10;&#10;            return listOf(&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Log(&quot;lastLog.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Ask(listOf(&quot;?&quot;)),&#10;                                    HardestCard(),&#10;                                    ResetStats(),&#10;                                    Log(&quot;lastLog.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Ask(listOf(&quot;?&quot;, &quot;?&quot;)),&#10;                                    HardestCard(),&#10;                                    Log(&quot;lastLog.txt&quot;),&#10;                                    ResetStats(),&#10;                                    Exit()&#10;                            ),&#10;                            false&#10;                    )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun revealRawTest(consoleInput: String, reply: String): String {&#10;    return &quot;Input:\n$consoleInput\nYour output:\n$reply\n\n&quot;&#10;}&#10;&#10;fun revealTestWithoutActions(&#10;        questions: List&lt;String&gt;,&#10;        answers: List&lt;String&gt;,&#10;        grades: List&lt;String&gt;&#10;): String {&#10;    val count = minOf(questions.size, answers.size, grades.size)&#10;&#10;    return &quot;Questions:\n\n&quot; +&#10;            (0 until count).joinToString(&quot;\n&quot;) {&#10;                &quot;Question:\n${questions[it]}\n&quot; +&#10;                        &quot;Answer:\n${answers[it]}\n&quot; +&#10;                        &quot;Grade:\n${grades[it]}\n&quot;&#10;            } +&#10;            &quot;\n&quot;&#10;}&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage567TestCommon.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage567TestCommon.kt" />
                                <option name="text" value="package common&#10;&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;&#10;fun checkStage567(reply: String, clue: FlashcardsStage567Clue): CheckResult {&#10;    val actionLines = splitReplyToActions(reply)&#10;&#10;    if (actionLines.size != clue.actions.size) {&#10;        val feedback = &quot;${actionLines.size} are found but ${clue.actions.size} actions have been inputted.&quot;&#10;&#10;        return if (clue.revealTest) {&#10;            CheckResult(false, revealRawTest(clue.consoleInput, reply) + feedback)&#10;        } else {&#10;            CheckResult(false, feedback)&#10;        }&#10;    }&#10;&#10;    val cards = Cards()&#10;&#10;    val checks = actionLines&#10;            .zip(clue.actions)&#10;            .map { (lines, action) -&gt; action.check(clue.revealTest, cards, lines) }&#10;&#10;    val firstUnsuccessful = checks.firstOrNull { !it.isCorrect }&#10;&#10;    if (firstUnsuccessful != null) {&#10;        return if (clue.revealTest) {&#10;            CheckResult(false, revealRawTest(clue.consoleInput, reply) + firstUnsuccessful.feedback)&#10;        } else {&#10;            CheckResult(false, firstUnsuccessful.feedback)&#10;        }&#10;    }&#10;&#10;    return CheckResult(true)&#10;}&#10;&#10;class FlashcardsStage567Clue(&#10;        val consoleInput: String,&#10;        val actions: List&lt;Action&gt;,&#10;        val revealTest: Boolean&#10;)&#10;&#10;fun createFlashcardsStage567TestCase(&#10;        actions: List&lt;Action&gt;,&#10;        revealTest: Boolean = false,&#10;        vararg args: String&#10;): TestCase&lt;FlashcardsStage567Clue&gt; {&#10;    val consoleInput = actions.flatMap { it.generateInput() }.joinToString(&quot;\n&quot;)&#10;&#10;    return TestCase&lt;FlashcardsStage567Clue&gt;()&#10;            .setInput(consoleInput)&#10;            .setAttach(FlashcardsStage567Clue(consoleInput, actions, revealTest))&#10;            .addArguments(*args)&#10;}&#10;&#10;fun splitReplyToActions(reply: String): List&lt;List&lt;String&gt;&gt; {&#10;    val answer = mutableListOf&lt;List&lt;String&gt;&gt;()&#10;&#10;    var lines = reply.lines().filter { it.isNotEmpty() }&#10;&#10;    while (lines.isNotEmpty()) {&#10;        val lastAction = lines.takeLastWhile { &quot;input the action&quot; !in it.toLowerCase() }&#10;&#10;        if (lines.size &gt; lastAction.size) {&#10;            answer.add(lastAction)&#10;            lines = lines.dropLast(lastAction.size + 1)&#10;        } else {&#10;            break  // if the first action doesn't contain &quot;input the action&quot; then it's not an action&#10;            // for example, it can be info about the program or lines about run arguments&#10;        }&#10;    }&#10;&#10;    return answer.reversed()&#10;}&#10;&#10;class Cards(&#10;        val cardToDefinition: MutableMap&lt;String, String&gt; = mutableMapOf(),&#10;        val definitionToCard: MutableMap&lt;String, String&gt; = mutableMapOf()&#10;)&#10;&#10;fun generateOldTests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;    return listOf(&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;a brother of one's parent&quot;, &quot;uncle&quot;),&#10;                            Add(&quot;a part of the body where the foot and the leg meet&quot;, &quot;ankle&quot;),&#10;                            Ask(listOf(&quot;ankle&quot;, &quot;??&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    true&#10;            ),&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;black&quot;, &quot;white&quot;),&#10;                            Add(&quot;black&quot;, &quot;pink&quot;),&#10;                            Add(&quot;black&quot;, &quot;yellow&quot;),&#10;                            Ask(listOf(&quot;white&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    true&#10;            ),&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;11&quot;, &quot;21&quot;),&#10;                            Add(&quot;12&quot;, &quot;22&quot;),&#10;                            Add(&quot;12&quot;, &quot;222&quot;),&#10;                            Ask(listOf(&quot;22&quot;, &quot;22&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    false&#10;            )&#10;    )&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage567TestCommonActions.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage567TestCommonActions.kt" />
                                <option name="text" value="package common&#10;&#10;import java.io.File&#10;&#10;open class ActionCheckResult(val isCorrect: Boolean, val feedback: String? = null)&#10;&#10;sealed class Action {&#10;    abstract fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult&#10;&#10;    abstract fun generateInput(): List&lt;String&gt;&#10;}&#10;&#10;class Add(private val card: String, private val definition: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 3) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 3 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 3 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val lastLine = replyLines.last()&#10;        val lastLineMeansAddition = '(' in lastLine&#10;&#10;        val cardAlreadyExists = card in cards.cardToDefinition&#10;&#10;        if (lastLineMeansAddition &amp;&amp; cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you add the card but &quot; +&#10;                                &quot;the card already exists.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you add the card which already exists.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!lastLineMeansAddition &amp;&amp; !cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you don't add the card but &quot; +&#10;                                &quot;the card doesn't already exist so you should.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't add the card which doesn't already exist.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!cardAlreadyExists) {&#10;            cards.cardToDefinition[card] = definition&#10;            cards.definitionToCard[definition] = card&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, card, definition)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;add&quot;&#10;    }&#10;}&#10;&#10;class Remove(private val card: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val lastLine = replyLines.last()&#10;        val lastLineMeansDeletion = &quot;can't remove&quot; !in lastLine.toLowerCase()&#10;&#10;        val cardAlreadyExists = card in cards.cardToDefinition&#10;&#10;        if (lastLineMeansDeletion &amp;&amp; !cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you remove the card but &quot; +&#10;                                &quot;the card doesn't already exist.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you remove the card which doesn't already exist.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!lastLineMeansDeletion &amp;&amp; cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you don't remove the card but &quot; +&#10;                                &quot;the card already exists so you should.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't remove the card which already exists.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (cardAlreadyExists) {&#10;            val definition = cards.cardToDefinition[card]&#10;            cards.cardToDefinition.remove(card)&#10;            cards.definitionToCard.remove(definition)&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, card)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;remove&quot;&#10;    }&#10;}&#10;&#10;class Import(private val fileName: String, private val expectedCardCount: Int) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCounts = replyLines&#10;                .last()&#10;                .split(&quot; &quot;)&#10;                .filter { it.isNotEmpty() &amp;&amp; it.all { c -&gt; c.isDigit() } }&#10;&#10;        if (cardCounts.size != 1) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 number.\n&quot; +&#10;                                &quot;Line: ${replyLines.last()}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 number.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCount = cardCounts.first().toInt()&#10;&#10;        if (cardCount != expectedCardCount) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you import an unexpected ($cardCount) amount of cards. &quot; +&#10;                                &quot;Expected: $expectedCardCount.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you import an unexpected amount of cards.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, fileName)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;import&quot;&#10;    }&#10;}&#10;&#10;class Export(private val fileName: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCounts = replyLines&#10;                .last()&#10;                .split(&quot; &quot;)&#10;                .filter { it.isNotEmpty() &amp;&amp; it.all { c -&gt; c.isDigit() } }&#10;&#10;        if (cardCounts.isEmpty()) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.\n&quot; +&#10;                                &quot;Line: ${replyLines.last()}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val file = File(fileName)&#10;&#10;        if (!file.exists()) {&#10;            ActionCheckResult(&#10;                    false,&#10;                    &quot;Action \&quot;$ACTION_NAME\&quot;: you don't create the file.&quot;&#10;            )&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, fileName)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;export&quot;&#10;    }&#10;}&#10;&#10;class Exit : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;exit&quot;&#10;    }&#10;}&#10;&#10;class Ask(private val answers: List&lt;String&gt;) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        val questionCount = answers.size&#10;&#10;        val questions = replyLines.takeLast(questionCount + 1).take(questionCount)&#10;        val grades = replyLines.takeLast(questionCount)&#10;&#10;        for (questionId in 0 until questionCount) {&#10;            val question = questions[questionId]&#10;            val answer = answers[questionId]&#10;            val grade = grades[questionId]&#10;&#10;            val hasCorrect = CORRECT.toLowerCase() in grade.toLowerCase()&#10;            val hasWrong = WRONG.toLowerCase() in grade.toLowerCase()&#10;&#10;            val card = question.substringBeforeLast('&quot;').substringAfterLast('&quot;')&#10;&#10;            val correctAnswer = cards.cardToDefinition[card] == answer&#10;&#10;            if (correctAnswer &amp;&amp; (hasWrong || !hasCorrect)) {&#10;                return if (revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is correct.&quot;&#10;&#10;                    ActionCheckResult(&#10;                            false,&#10;                            revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    ActionCheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; (hasCorrect || !hasWrong)) {&#10;                return if (revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is wrong.&quot;&#10;&#10;                    ActionCheckResult(&#10;                            false,&#10;                            revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    ActionCheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer) {&#10;                val suggestedDefinition = grade.substringAfter('&quot;').substringBefore('&quot;')&#10;&#10;                if (suggestedDefinition != cards.cardToDefinition[card]) {&#10;                    return if (revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$suggestedDefinition\&quot; is correct but it isn't.&quot;&#10;&#10;                        ActionCheckResult(&#10;                                false,&#10;                                revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        ActionCheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; answer in cards.definitionToCard) {&#10;                val originalCard = grade&#10;                        .substringAfter('&quot;')&#10;                        .substringAfter('&quot;')&#10;                        .substringAfter('&quot;')&#10;                        .substringBefore('&quot;')&#10;&#10;                if (originalCard != cards.definitionToCard[answer]) {&#10;                    return if (revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$originalCard\&quot; card is the original one but it isn't.&quot;&#10;&#10;                        ActionCheckResult(&#10;                                false,&#10;                                revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        ActionCheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, answers.size.toString()) + answers&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;ask&quot;&#10;&#10;        private const val CORRECT = &quot;correct answer&quot;&#10;        private const val WRONG = &quot;wrong answer&quot;&#10;    }&#10;}&#10;&#10;class Log(private val fileName: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val file = File(fileName)&#10;&#10;        if (!file.exists()) {&#10;            ActionCheckResult(&#10;                    false,&#10;                    &quot;Action \&quot;$ACTION_NAME\&quot;: you don't create the file.&quot;&#10;            )&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, fileName)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;log&quot;&#10;    }&#10;}&#10;&#10;// TODO: check the value&#10;class HardestCard : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 1) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 line.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 line.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCounts = replyLines&#10;                .last()&#10;                .split(&quot; &quot;)&#10;                .filter { it.isNotEmpty() &amp;&amp; it.all { c -&gt; c.isDigit() } }&#10;&#10;        if (cardCounts.isEmpty()) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.\n&quot; +&#10;                                &quot;Line: ${replyLines.last()}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;hardest card&quot;&#10;    }&#10;}&#10;&#10;class ResetStats : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;reset stats&quot;&#10;    }&#10;}" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="src/flashcards/Main.java" />
                                <option name="text" value="package flashcards;&#10;&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Hello World!&quot;);&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/FlashCard.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/FlashCard.java" />
                                <option name="text" value="package flashcards;&#10;&#10;import java.io.File;&#10;import java.io.FileNotFoundException;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.util.*;&#10;&#10;class FlashCard {&#10;&#10;    public enum InputAction {&#10;        ADD, REMOVE, IMPORT, EXPORT, ASK, EXIT&#10;    }&#10;&#10;    private final static String savePath = &quot;C:\\Users\\A760323\\&quot;;&#10;&#10;    private Map&lt;String, String&gt; cardToDefinition = new LinkedHashMap&lt;&gt;();&#10;    private Map&lt;String, String&gt; definitionToCard = new LinkedHashMap&lt;&gt;();&#10;&#10;    void run() {&#10;&#10;        Scanner scanner = new Scanner(System.in);&#10;&#10;        InputAction userInput = inputAction(scanner);&#10;&#10;        while (!userInput.equals(InputAction.EXIT)) {&#10;            switch (userInput) {&#10;                case ADD:&#10;                    addCard(scanner);&#10;                    break;&#10;                case REMOVE:&#10;                    removeCard(scanner);&#10;                    break;&#10;                case ASK:&#10;                    askCard(scanner);&#10;                    break;&#10;                case IMPORT:&#10;                    importCards(scanner);&#10;                    break;&#10;                case EXPORT:&#10;                    exportCards(scanner);&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;            System.out.println();&#10;            userInput = inputAction(scanner);&#10;        }&#10;        System.out.println(&quot;Bye bye!&quot;);&#10;    }&#10;&#10;    private void addCard(Scanner s) {&#10;        System.out.println(&quot;The card:&quot;);&#10;        String card = s.nextLine();&#10;        boolean doAdd = true;&#10;        if (cardToDefinition.containsKey(card)) {&#10;            System.out.println(String.format(&quot;\&quot;%s\&quot; is already on another card. Try again.&quot;, card));&#10;            //addCard(s);&#10;            //return;&#10;            doAdd = false;&#10;        }&#10;&#10;        System.out.println(&quot;The definition of the card:&quot;);&#10;        String definition = s.nextLine();&#10;&#10;        if (definitionToCard.containsKey(definition)) {&#10;            System.out.println(String.format(&quot;\&quot;%s\&quot; is already defined on another card. Try again.&quot;, card));&#10;            //addCard(s);&#10;            //return;&#10;            doAdd = false;&#10;        }&#10;        if (doAdd) {&#10;            definitionToCard.put(definition, card);&#10;            cardToDefinition.put(card, definition);&#10;&#10;            System.out.println(String.format(&quot;The pair (\&quot;%s\&quot;:\&quot;%s\&quot;) is added.&quot;, card, definition));&#10;        }&#10;    }&#10;&#10;    private void removeCard(Scanner s) {&#10;        System.out.println(&quot;The card:&quot;);&#10;        String card = s.nextLine();&#10;&#10;        if (cardToDefinition.containsKey(card)) {&#10;            String definition = cardToDefinition.get(card);&#10;            cardToDefinition.remove(card);&#10;            definitionToCard.remove(definition);&#10;            System.out.println(String.format(&quot;Card \&quot;%s\&quot; removed.&quot;, card));&#10;        } else {&#10;            System.out.println(String.format(&quot;Can't remove \&quot;%s\&quot;: There is no such card.&quot;, card));&#10;        }&#10;    }&#10;&#10;    private void askCard(Scanner s) {&#10;        System.out.println(&quot;How many times to ask?&quot;);&#10;        int numberOfQuestions = Integer.parseInt(s.nextLine());&#10;&#10;        Random random = new Random();&#10;        int from = 0;&#10;        int to = cardToDefinition.size();&#10;&#10;        for (int i = 0; i &lt; numberOfQuestions; i++) {&#10;&#10;            String[] cards = cardToDefinition.keySet().toArray(new String[0]);&#10;            String card = cards[random.nextInt(to - from) + from];&#10;&#10;            System.out.println(String.format(&quot;Print the definition of \&quot;%s\&quot;:&quot;, card));&#10;            String answer = s.nextLine();&#10;            if (cardToDefinition.get(card).equals(answer)) {&#10;                System.out.print(&quot;Correct answer. &quot;);&#10;            } else {&#10;                if (definitionToCard.containsKey(answer)) {&#10;                    System.out.print(String.format(&quot;Wrong answer (the correct one is \&quot;%s\&quot;, you've just written a definition of \&quot;%s\&quot; card). &quot;, cardToDefinition.get(card), definitionToCard.get(answer)));&#10;                } else {&#10;                    System.out.print(String.format(&quot;Wrong answer (the correct one is \&quot;%s\&quot;). &quot;, cardToDefinition.get(card)));&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void exportCards(Scanner s) {&#10;&#10;        System.out.println(&quot;File name:&quot;);&#10;        String fileName = s.nextLine();&#10;&#10;        File saveFile = new File(savePath + fileName);&#10;&#10;        try (FileWriter fileWriter = new FileWriter(saveFile)) {&#10;            for (Map.Entry card : cardToDefinition.entrySet()) {&#10;                fileWriter.write(card.getKey() + &quot;\n&quot;);&#10;                fileWriter.write(card.getValue() + &quot;\n&quot;);&#10;            }&#10;            System.out.println(String.format(&quot;%d cards have been saved&quot;, cardToDefinition.size()));&#10;        } catch (IOException e) {&#10;            System.out.println(String.format(&quot;%d cards have been saved&quot;, 0));&#10;        }&#10;    }&#10;&#10;    private void importCards(Scanner s) {&#10;        System.out.println(&quot;File name:&quot;);&#10;        String fileName = s.nextLine();&#10;&#10;        File saveFile = new File(savePath + fileName);&#10;&#10;        try (Scanner fileReader = new Scanner(saveFile)) {&#10;            boolean isDefinition = false;&#10;            int pairIndex = 0;&#10;            LinkedHashMap&lt;Integer, String&gt; cards = new LinkedHashMap&lt;&gt;();&#10;            LinkedHashMap&lt;Integer, String&gt; definitions = new LinkedHashMap&lt;&gt;();&#10;&#10;            while (fileReader.hasNextLine()) {&#10;                String importString = fileReader.nextLine();&#10;                if (!isDefinition) {&#10;                    cards.put(pairIndex, importString);&#10;                    isDefinition = true;&#10;                } else {&#10;                    definitions.put(pairIndex, importString);&#10;                    pairIndex++;&#10;                    isDefinition = false;&#10;                }&#10;            }&#10;            for (Map.Entry &lt;Integer, String&gt; entry : cards.entrySet()) {&#10;                cardToDefinition.put(entry.getValue(), definitions.get(entry.getKey()));&#10;                definitionToCard.put(definitions.get(entry.getKey()), entry.getValue());&#10;            }&#10;&#10;            System.out.println(String.format(&quot;%d cards have been loaded.&quot;, pairIndex));&#10;&#10;        } catch (FileNotFoundException e) {&#10;            System.out.println(String.format(&quot;%d cards have been loaded.&quot;, 0));&#10;        }&#10;    }&#10;&#10;    private static InputAction inputAction(Scanner s) {&#10;        StringBuilder actions = new StringBuilder();&#10;&#10;        ArrayList&lt;InputAction&gt; actionsList = new ArrayList&lt;&gt;();&#10;&#10;        Collections.addAll(actionsList, InputAction.values());&#10;        Iterator actionsIterator = actionsList.iterator();&#10;&#10;        while (actionsIterator.hasNext()) {&#10;            InputAction action = (InputAction)actionsIterator.next();&#10;            actions.append(action.toString().toLowerCase());&#10;            if (actionsIterator.hasNext()) {&#10;                actions.append(&quot;, &quot;);&#10;            }&#10;        }&#10;        System.out.println(String.format(&quot;Input the action (%s):&quot;, actions.toString()));&#10;        String userAction = s.nextLine();&#10;        try {&#10;            return InputAction.valueOf(userAction.toUpperCase());&#10;        } catch (IllegalArgumentException e) {&#10;            System.out.println(&quot;Invalid input. Try again.&quot;);&#10;            return inputAction(s);&#10;        }&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.class">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="src/flashcards/Main.class" />
                                <option name="text" value="&#10;  // IntelliJ API Decompiler stub source generated from a class file&#10;  // Implementation of methods is not available&#10;&#10;package corrupted_class_files;&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1562385274000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Users often use files to save their progress and restore it the next time they run the program. It's tedious to print the actions manually. Sometimes you can just forget to do it! So let's add run arguments that define which file to read at the start and which file to save at the exit.&lt;/p&gt;&#10;&#10;&lt;p&gt;For the program to read from an external file, you should pass the argument &lt;code&gt;-import&lt;/code&gt; and follow it with the file name. If such argument is not set, the set of cards should be initially empty.&lt;/p&gt;&#10;&#10;&lt;p&gt;If &lt;code&gt;-export&lt;/code&gt; argument is set and it is followed by the file name, you should write all the cards that are in the program memory into this file after the user has entered exit.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Run arguments examples&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;java Flashcards -import derivatives.txt&#10;&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;java Flashcards -export animals.txt&#10;&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;java Flashcards -import words13june.txt -export words14june.txt&#10;&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;java Flashcards -import vocab.txt -export vocab.txt&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/44/stages/238/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="5349" />
                      <option name="index" value="7" />
                      <option name="name" value="IMPORTant" />
                      <option name="record" value="-1" />
                      <option name="status" value="Solved" />
                      <option name="files">
                        <map>
                          <entry key="test/FlashcardsTest.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/FlashcardsTest.java" />
                                <option name="text" value="import common.FlashcardsStage7Test;&#10;&#10;public class FlashcardsTest extends FlashcardsStage7Test {&#10;    // just empty class, but not abstract so it can be run&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage7Test.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage7Test.kt" />
                                <option name="text" value="package common&#10;&#10;import org.hyperskill.hstest.v5.stage.BaseStageTest&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;import flashcards.Main&#10;&#10;&#10;abstract class FlashcardsStage7Test : BaseStageTest&lt;FlashcardsStage567Clue&gt;(Main::class.java) {&#10;&#10;    override fun generate(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;        return createStage7Tests() + createStage6Tests() + createStage5Tests() + generateOldTests()&#10;    }&#10;&#10;    /**&#10;     * This stage is auto-graded.&#10;     *&#10;     * The grader skips empty lines.&#10;     *&#10;     * Every action must start with words &quot;input the action&quot;.&#10;     *&#10;     * The behaviour of &quot;ask&quot; action is the same as the behaviour of the previous stage.&#10;     *&#10;     * Please check the console example.&#10;     */&#10;    override fun check(reply: String, clue: FlashcardsStage567Clue): CheckResult {&#10;        return checkStage567(reply, clue)&#10;    }&#10;&#10;    companion object {&#10;&#10;        fun createStage5Tests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;            // TODO: how to remove files? Now at least rewrite at the first test:&#10;&#10;            return listOf(&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Export(&quot;capitals.txt&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Remove(&quot;Wakanda&quot;),&#10;                                    Import(&quot;capitals.txt&quot;, 0),&#10;                                    Ask(listOf(&quot;London&quot;)),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 1),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 1),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 3),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 3),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 4),&#10;                                    Exit()&#10;                            ),&#10;                            false&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Add(&quot;London&quot;, &quot;Big Ben&quot;),&#10;                                    Remove(&quot;London&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 4),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Add(&quot;Japan&quot;, &quot;Tokyo&quot;),&#10;                                    Add(&quot;London&quot;, &quot;Big Ben&quot;),&#10;                                    Remove(&quot;London&quot;),&#10;                                    Remove(&quot;Russia&quot;),&#10;                                    Remove(&quot;Japan&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Import(&quot;capitalsNew.txt&quot;, 2),&#10;                                    Exit()&#10;                            ),&#10;                            false&#10;                    )&#10;            )&#10;        }&#10;&#10;        fun createStage6Tests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;            // TODO: how to remove files? Now at least rewrite at the first test:&#10;&#10;            return listOf(&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Log(&quot;lastLog.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Ask(listOf(&quot;?&quot;)),&#10;                                    HardestCard(),&#10;                                    ResetStats(),&#10;                                    Log(&quot;lastLog.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Ask(listOf(&quot;?&quot;, &quot;?&quot;)),&#10;                                    HardestCard(),&#10;                                    Log(&quot;lastLog.txt&quot;),&#10;                                    ResetStats(),&#10;                                    Exit()&#10;                            ),&#10;                            false&#10;                    )&#10;            )&#10;        }&#10;&#10;        fun createStage7Tests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;            // TODO: how to remove files? Now at least rewrite at the first test:&#10;&#10;            return listOf(&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;Great Britain&quot;, &quot;London&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true,&#10;                            &quot;-export&quot;, &quot;capitalsNew.txt&quot;&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 1),&#10;                                    Add(&quot;Russia&quot;, &quot;Moscow&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true,&#10;                            &quot;-export&quot;, &quot;capitalsNew.txt&quot;&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Add(&quot;France&quot;, &quot;Paris&quot;),&#10;                                    Export(&quot;capitalsNew.txt&quot;),&#10;                                    Exit()&#10;                            ),&#10;                            true,&#10;                            &quot;-import&quot;, &quot;capitalsNew.txt&quot;&#10;                    ),&#10;                    createFlashcardsStage567TestCase(&#10;                            listOf(&#10;                                    Import(&quot;capitalsNew.txt&quot;, 3),&#10;                                    Exit()&#10;                            ),&#10;                            true&#10;                    )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun revealRawTest(consoleInput: String, reply: String): String {&#10;    return &quot;Input:\n$consoleInput\nYour output:\n$reply\n\n&quot;&#10;}&#10;&#10;fun revealTestWithoutActions(&#10;        questions: List&lt;String&gt;,&#10;        answers: List&lt;String&gt;,&#10;        grades: List&lt;String&gt;&#10;): String {&#10;    val count = minOf(questions.size, answers.size, grades.size)&#10;&#10;    return &quot;Questions:\n\n&quot; +&#10;            (0 until count).joinToString(&quot;\n&quot;) {&#10;                &quot;Question:\n${questions[it]}\n&quot; +&#10;                        &quot;Answer:\n${answers[it]}\n&quot; +&#10;                        &quot;Grade:\n${grades[it]}\n&quot;&#10;            } +&#10;            &quot;\n&quot;&#10;}&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage567TestCommon.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage567TestCommon.kt" />
                                <option name="text" value="package common&#10;&#10;import org.hyperskill.hstest.v5.testcase.CheckResult&#10;import org.hyperskill.hstest.v5.testcase.TestCase&#10;&#10;fun checkStage567(reply: String, clue: FlashcardsStage567Clue): CheckResult {&#10;    val actionLines = splitReplyToActions(reply)&#10;&#10;    if (actionLines.size != clue.actions.size) {&#10;        val feedback = &quot;${actionLines.size} are found but ${clue.actions.size} actions have been inputted.&quot;&#10;&#10;        return if (clue.revealTest) {&#10;            CheckResult(false, revealRawTest(clue.consoleInput, reply) + feedback)&#10;        } else {&#10;            CheckResult(false, feedback)&#10;        }&#10;    }&#10;&#10;    val cards = Cards()&#10;&#10;    val checks = actionLines&#10;            .zip(clue.actions)&#10;            .map { (lines, action) -&gt; action.check(clue.revealTest, cards, lines) }&#10;&#10;    val firstUnsuccessful = checks.firstOrNull { !it.isCorrect }&#10;&#10;    if (firstUnsuccessful != null) {&#10;        return if (clue.revealTest) {&#10;            CheckResult(false, revealRawTest(clue.consoleInput, reply) + firstUnsuccessful.feedback)&#10;        } else {&#10;            CheckResult(false, firstUnsuccessful.feedback)&#10;        }&#10;    }&#10;&#10;    return CheckResult(true)&#10;}&#10;&#10;class FlashcardsStage567Clue(&#10;        val consoleInput: String,&#10;        val actions: List&lt;Action&gt;,&#10;        val revealTest: Boolean&#10;)&#10;&#10;fun createFlashcardsStage567TestCase(&#10;        actions: List&lt;Action&gt;,&#10;        revealTest: Boolean = false,&#10;        vararg args: String&#10;): TestCase&lt;FlashcardsStage567Clue&gt; {&#10;    val consoleInput = actions.flatMap { it.generateInput() }.joinToString(&quot;\n&quot;)&#10;&#10;    return TestCase&lt;FlashcardsStage567Clue&gt;()&#10;            .setInput(consoleInput)&#10;            .setAttach(FlashcardsStage567Clue(consoleInput, actions, revealTest))&#10;            .addArguments(*args)&#10;}&#10;&#10;fun splitReplyToActions(reply: String): List&lt;List&lt;String&gt;&gt; {&#10;    val answer = mutableListOf&lt;List&lt;String&gt;&gt;()&#10;&#10;    var lines = reply.lines().filter { it.isNotEmpty() }&#10;&#10;    while (lines.isNotEmpty()) {&#10;        val lastAction = lines.takeLastWhile { &quot;input the action&quot; !in it.toLowerCase() }&#10;&#10;        if (lines.size &gt; lastAction.size) {&#10;            answer.add(lastAction)&#10;            lines = lines.dropLast(lastAction.size + 1)&#10;        } else {&#10;            break  // if the first action doesn't contain &quot;input the action&quot; then it's not an action&#10;            // for example, it can be info about the program or lines about run arguments&#10;        }&#10;    }&#10;&#10;    return answer.reversed()&#10;}&#10;&#10;class Cards(&#10;        val cardToDefinition: MutableMap&lt;String, String&gt; = mutableMapOf(),&#10;        val definitionToCard: MutableMap&lt;String, String&gt; = mutableMapOf()&#10;)&#10;&#10;fun generateOldTests(): List&lt;TestCase&lt;FlashcardsStage567Clue&gt;&gt; {&#10;    return listOf(&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;a brother of one's parent&quot;, &quot;uncle&quot;),&#10;                            Add(&quot;a part of the body where the foot and the leg meet&quot;, &quot;ankle&quot;),&#10;                            Ask(listOf(&quot;ankle&quot;, &quot;??&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    true&#10;            ),&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;black&quot;, &quot;white&quot;),&#10;                            Add(&quot;black&quot;, &quot;pink&quot;),&#10;                            Add(&quot;black&quot;, &quot;yellow&quot;),&#10;                            Ask(listOf(&quot;white&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    true&#10;            ),&#10;            createFlashcardsStage567TestCase(&#10;                    listOf(&#10;                            Add(&quot;11&quot;, &quot;21&quot;),&#10;                            Add(&quot;12&quot;, &quot;22&quot;),&#10;                            Add(&quot;12&quot;, &quot;222&quot;),&#10;                            Ask(listOf(&quot;22&quot;, &quot;22&quot;)),&#10;                            Exit()&#10;                    ),&#10;                    false&#10;            )&#10;    )&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="test/common/FlashcardsStage567TestCommonActions.kt">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="test/common/FlashcardsStage567TestCommonActions.kt" />
                                <option name="text" value="package common&#10;&#10;import java.io.File&#10;&#10;open class ActionCheckResult(val isCorrect: Boolean, val feedback: String? = null)&#10;&#10;sealed class Action {&#10;    abstract fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult&#10;&#10;    abstract fun generateInput(): List&lt;String&gt;&#10;}&#10;&#10;class Add(private val card: String, private val definition: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 3) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 3 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 3 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val lastLine = replyLines.last()&#10;        val lastLineMeansAddition = '(' in lastLine&#10;&#10;        val cardAlreadyExists = card in cards.cardToDefinition&#10;&#10;        if (lastLineMeansAddition &amp;&amp; cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you add the card but &quot; +&#10;                                &quot;the card already exists.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you add the card which already exists.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!lastLineMeansAddition &amp;&amp; !cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you don't add the card but &quot; +&#10;                                &quot;the card doesn't already exist so you should.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't add the card which doesn't already exist.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!cardAlreadyExists) {&#10;            cards.cardToDefinition[card] = definition&#10;            cards.definitionToCard[definition] = card&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, card, definition)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;add&quot;&#10;    }&#10;}&#10;&#10;class Remove(private val card: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val lastLine = replyLines.last()&#10;        val lastLineMeansDeletion = &quot;can't remove&quot; !in lastLine.toLowerCase()&#10;&#10;        val cardAlreadyExists = card in cards.cardToDefinition&#10;&#10;        if (lastLineMeansDeletion &amp;&amp; !cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you remove the card but &quot; +&#10;                                &quot;the card doesn't already exist.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you remove the card which doesn't already exist.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (!lastLineMeansDeletion &amp;&amp; cardAlreadyExists) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: the \&quot;$lastLine\&quot; line means you don't remove the card but &quot; +&#10;                                &quot;the card already exists so you should.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't remove the card which already exists.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (cardAlreadyExists) {&#10;            val definition = cards.cardToDefinition[card]&#10;            cards.cardToDefinition.remove(card)&#10;            cards.definitionToCard.remove(definition)&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, card)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;remove&quot;&#10;    }&#10;}&#10;&#10;class Import(private val fileName: String, private val expectedCardCount: Int) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCounts = replyLines&#10;                .last()&#10;                .split(&quot; &quot;)&#10;                .filter { it.isNotEmpty() &amp;&amp; it.all { c -&gt; c.isDigit() } }&#10;&#10;        if (cardCounts.size != 1) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 number.\n&quot; +&#10;                                &quot;Line: ${replyLines.last()}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 number.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCount = cardCounts.first().toInt()&#10;&#10;        if (cardCount != expectedCardCount) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you import an unexpected ($cardCount) amount of cards. &quot; +&#10;                                &quot;Expected: $expectedCardCount.&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you import an unexpected amount of cards.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, fileName)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;import&quot;&#10;    }&#10;}&#10;&#10;class Export(private val fileName: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCounts = replyLines&#10;                .last()&#10;                .split(&quot; &quot;)&#10;                .filter { it.isNotEmpty() &amp;&amp; it.all { c -&gt; c.isDigit() } }&#10;&#10;        if (cardCounts.isEmpty()) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.\n&quot; +&#10;                                &quot;Line: ${replyLines.last()}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val file = File(fileName)&#10;&#10;        if (!file.exists()) {&#10;            ActionCheckResult(&#10;                    false,&#10;                    &quot;Action \&quot;$ACTION_NAME\&quot;: you don't create the file.&quot;&#10;            )&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, fileName)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;export&quot;&#10;    }&#10;}&#10;&#10;class Exit : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;exit&quot;&#10;    }&#10;}&#10;&#10;class Ask(private val answers: List&lt;String&gt;) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        val questionCount = answers.size&#10;&#10;        val questions = replyLines.takeLast(questionCount + 1).take(questionCount)&#10;        val grades = replyLines.takeLast(questionCount)&#10;&#10;        for (questionId in 0 until questionCount) {&#10;            val question = questions[questionId]&#10;            val answer = answers[questionId]&#10;            val grade = grades[questionId]&#10;&#10;            val hasCorrect = CORRECT.toLowerCase() in grade.toLowerCase()&#10;            val hasWrong = WRONG.toLowerCase() in grade.toLowerCase()&#10;&#10;            val card = question.substringBeforeLast('&quot;').substringAfterLast('&quot;')&#10;&#10;            val correctAnswer = cards.cardToDefinition[card] == answer&#10;&#10;            if (correctAnswer &amp;&amp; (hasWrong || !hasCorrect)) {&#10;                return if (revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is correct.&quot;&#10;&#10;                    ActionCheckResult(&#10;                            false,&#10;                            revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    ActionCheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; (hasCorrect || !hasWrong)) {&#10;                return if (revealTest) {&#10;                    val feedback = &quot;Mistake:\n\n&quot; +&#10;                            &quot;Question:\n$question\n&quot; +&#10;                            &quot;Answer:\n$answer\n&quot; +&#10;                            &quot;Grade:\n$grade\n&quot; +&#10;                            &quot;The grade doesn't say the answer is wrong.&quot;&#10;&#10;                    ActionCheckResult(&#10;                            false,&#10;                            revealTestWithoutActions(questions, answers, grades) +&#10;                                    feedback&#10;                    )&#10;                } else {&#10;                    ActionCheckResult(false)&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer) {&#10;                val suggestedDefinition = grade.substringAfter('&quot;').substringBefore('&quot;')&#10;&#10;                if (suggestedDefinition != cards.cardToDefinition[card]) {&#10;                    return if (revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$suggestedDefinition\&quot; is correct but it isn't.&quot;&#10;&#10;                        ActionCheckResult(&#10;                                false,&#10;                                revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        ActionCheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (!correctAnswer &amp;&amp; answer in cards.definitionToCard) {&#10;                val originalCard = grade&#10;                        .substringAfter('&quot;')&#10;                        .substringAfter('&quot;')&#10;                        .substringAfter('&quot;')&#10;                        .substringBefore('&quot;')&#10;&#10;                if (originalCard != cards.definitionToCard[answer]) {&#10;                    return if (revealTest) {&#10;                        val feedback = &quot;Mistake:\n\n&quot; +&#10;                                &quot;Question:\n$question\n&quot; +&#10;                                &quot;Answer:\n$answer\n&quot; +&#10;                                &quot;Grade:\n$grade\n&quot; +&#10;                                &quot;The grade says the \&quot;$originalCard\&quot; card is the original one but it isn't.&quot;&#10;&#10;                        ActionCheckResult(&#10;                                false,&#10;                                revealTestWithoutActions(questions, answers, grades) +&#10;                                        feedback&#10;                        )&#10;                    } else {&#10;                        ActionCheckResult(false)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, answers.size.toString()) + answers&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;ask&quot;&#10;&#10;        private const val CORRECT = &quot;correct answer&quot;&#10;        private const val WRONG = &quot;wrong answer&quot;&#10;    }&#10;}&#10;&#10;class Log(private val fileName: String) : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 2) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 2 lines.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val file = File(fileName)&#10;&#10;        if (!file.exists()) {&#10;            ActionCheckResult(&#10;                    false,&#10;                    &quot;Action \&quot;$ACTION_NAME\&quot;: you don't create the file.&quot;&#10;            )&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME, fileName)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;log&quot;&#10;    }&#10;}&#10;&#10;// TODO: check the value&#10;class HardestCard : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        if (replyLines.size != 1) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 line.\n&quot; +&#10;                                &quot;Lines: ${replyLines.joinToString(prefix = &quot;(&quot;, postfix = &quot;)&quot;)}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output exactly 1 line.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        val cardCounts = replyLines&#10;                .last()&#10;                .split(&quot; &quot;)&#10;                .filter { it.isNotEmpty() &amp;&amp; it.all { c -&gt; c.isDigit() } }&#10;&#10;        if (cardCounts.isEmpty()) {&#10;            return if (revealTest) {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.\n&quot; +&#10;                                &quot;Line: ${replyLines.last()}&quot;&#10;                )&#10;            } else {&#10;                ActionCheckResult(&#10;                        false,&#10;                        &quot;Action \&quot;$ACTION_NAME\&quot;: you don't output any numbers.&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;hardest card&quot;&#10;    }&#10;}&#10;&#10;class ResetStats : Action() {&#10;&#10;    override fun check(revealTest: Boolean, cards: Cards, replyLines: List&lt;String&gt;): ActionCheckResult {&#10;        return ActionCheckResult(true)&#10;    }&#10;&#10;    override fun generateInput(): List&lt;String&gt; {&#10;        return listOf(ACTION_NAME)&#10;    }&#10;&#10;    companion object {&#10;        private const val ACTION_NAME = &quot;reset stats&quot;&#10;    }&#10;}" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/Main.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/Main.java" />
                                <option name="text" value="package flashcards;&#10;&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Hello World!&quot;);&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="src/flashcards/FlashCard.java">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="src/flashcards/FlashCard.java" />
                                <option name="text" value="package flashcards;&#10;&#10;import java.io.File;&#10;import java.io.FileNotFoundException;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.util.*;&#10;&#10;class FlashCard {&#10;&#10;    public enum InputAction {&#10;        ADD, REMOVE, IMPORT, EXPORT, ASK, EXIT, LOG, HARDEST_CARD, RESET_STATS&#10;    }&#10;&#10;    private final static String savePath = &quot;C:\\Users\\A760323\\&quot;;&#10;&#10;    private Map&lt;String, String&gt; cardToDefinition = new LinkedHashMap&lt;&gt;();&#10;    private Map&lt;String, String&gt; definitionToCard = new LinkedHashMap&lt;&gt;();&#10;    private Map&lt;String, Integer&gt; cardStatistics = new LinkedHashMap&lt;&gt;();&#10;    private ArrayList&lt;String&gt; appLog = new ArrayList&lt;&gt;();&#10;&#10;    void run() {&#10;&#10;        Scanner scanner = new Scanner(System.in);&#10;&#10;        InputAction userInput = inputAction(scanner);&#10;&#10;        while (!userInput.equals(InputAction.EXIT)) {&#10;            switch (userInput) {&#10;                case ADD:&#10;                    addCard(scanner);&#10;                    break;&#10;                case REMOVE:&#10;                    removeCard(scanner);&#10;                    break;&#10;                case ASK:&#10;                    askCard(scanner);&#10;                    break;&#10;                case IMPORT:&#10;                    importCards(scanner);&#10;                    break;&#10;                case EXPORT:&#10;                    exportCards(scanner);&#10;                    break;&#10;                case LOG:&#10;                    saveLog(scanner);&#10;                    break;&#10;                case HARDEST_CARD:&#10;                    hardestCard();&#10;                    break;&#10;                case RESET_STATS:&#10;                    resetStats();&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;            printLnOut();&#10;            userInput = inputAction(scanner);&#10;        }&#10;        printLnOut(&quot;Bye bye!&quot;);&#10;    }&#10;&#10;    private String getInput(Scanner s) {&#10;        String input = s.nextLine();&#10;        appLog.add(input + &quot;\n&quot;);&#10;        return input;&#10;    }&#10;&#10;    private void printLnOut() {&#10;        printLnOut(&quot;&quot;);&#10;    }&#10;&#10;    private void printLnOut(String output) {&#10;        appLog.add(output + &quot;\n&quot;);&#10;        System.out.println(output);&#10;    }&#10;&#10;    private void printOut(String output) {&#10;        String lastStringFromLog = appLog.get(appLog.size()-1);&#10;        if (lastStringFromLog.endsWith(&quot;\n&quot;)) {&#10;            appLog.add(output);&#10;        } else {&#10;            appLog.set(appLog.size() - 1, lastStringFromLog + output);&#10;        }&#10;        System.out.print(output);&#10;    }&#10;&#10;    private void addCard(Scanner s) {&#10;        printLnOut(&quot;The card:&quot;);&#10;        String card = getInput(s);&#10;        boolean doAdd = true;&#10;        if (cardToDefinition.containsKey(card)) {&#10;            printLnOut(String.format(&quot;\&quot;%s\&quot; is already on another card. Try again.&quot;, card));&#10;            //addCard(s);&#10;            //return;&#10;            doAdd = false;&#10;        }&#10;&#10;        printLnOut(&quot;The definition of the card:&quot;);&#10;        String definition = getInput(s);&#10;&#10;        if (definitionToCard.containsKey(definition)) {&#10;            printLnOut(String.format(&quot;\&quot;%s\&quot; is already defined on another card. Try again.&quot;, card));&#10;            //addCard(s);&#10;            //return;&#10;            doAdd = false;&#10;        }&#10;        if (doAdd) {&#10;            definitionToCard.put(definition, card);&#10;            cardToDefinition.put(card, definition);&#10;            cardStatistics.put(card, 0);&#10;&#10;            printLnOut(String.format(&quot;The pair (\&quot;%s\&quot;:\&quot;%s\&quot;) is added.&quot;, card, definition));&#10;        }&#10;    }&#10;&#10;    private void removeCard(Scanner s) {&#10;        printLnOut(&quot;The card:&quot;);&#10;        String card = getInput(s);&#10;&#10;        if (cardToDefinition.containsKey(card)) {&#10;            String definition = cardToDefinition.get(card);&#10;            cardToDefinition.remove(card);&#10;            definitionToCard.remove(definition);&#10;            cardStatistics.remove(card);&#10;            printLnOut(String.format(&quot;Card \&quot;%s\&quot; removed.&quot;, card));&#10;        } else {&#10;            printLnOut(String.format(&quot;Can't remove \&quot;%s\&quot;: There is no such card.&quot;, card));&#10;        }&#10;    }&#10;&#10;    private void askCard(Scanner s) {&#10;        printLnOut(&quot;How many times to ask?&quot;);&#10;        int numberOfQuestions = Integer.parseInt(getInput(s));&#10;&#10;        Random random = new Random();&#10;        int from = 0;&#10;        int to = cardToDefinition.size();&#10;&#10;        for (int i = 0; i &lt; numberOfQuestions; i++) {&#10;&#10;            String[] cards = cardToDefinition.keySet().toArray(new String[0]);&#10;            String card = cards[random.nextInt(to - from) + from];&#10;&#10;            printLnOut(String.format(&quot;Print the definition of \&quot;%s\&quot;:&quot;, card));&#10;            String answer = getInput(s);&#10;            if (cardToDefinition.get(card).equals(answer)) {&#10;                printOut(&quot;Correct answer. &quot;);&#10;            } else {&#10;                if (definitionToCard.containsKey(answer)) {&#10;                    printOut(String.format(&quot;Wrong answer (the correct one is \&quot;%s\&quot;, you've just written a definition of \&quot;%s\&quot; card). &quot;, cardToDefinition.get(card), definitionToCard.get(answer)));&#10;                } else {&#10;                    printOut(String.format(&quot;Wrong answer (the correct one is \&quot;%s\&quot;). &quot;, cardToDefinition.get(card)));&#10;                }&#10;                Integer currentStats = cardStatistics.get(card);&#10;                cardStatistics.put(card, ++currentStats);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void exportCards(Scanner s) {&#10;&#10;        printLnOut(&quot;File name:&quot;);&#10;        String fileName = getInput(s);&#10;&#10;        File saveFile = new File(savePath + fileName);&#10;&#10;        try (FileWriter fileWriter = new FileWriter(saveFile)) {&#10;            for (Map.Entry&lt;String, String&gt; card : cardToDefinition.entrySet()) {&#10;                fileWriter.write(card.getKey() + &quot;\n&quot;);&#10;                fileWriter.write(card.getValue() + &quot;\n&quot;);&#10;                fileWriter.write(cardStatistics.get(card.getKey()) + &quot;\n&quot;);&#10;            }&#10;            printLnOut(String.format(&quot;%d cards have been saved&quot;, cardToDefinition.size()));&#10;        } catch (IOException e) {&#10;            printLnOut(String.format(&quot;%d cards have been saved&quot;, 0));&#10;        }&#10;    }&#10;&#10;    private void hardestCard() {&#10;        Integer maxErrors = 0;&#10;        String hardestCard = &quot;&quot;;&#10;&#10;        for (Map.Entry&lt;String, Integer&gt; cardStatistic : cardStatistics.entrySet()) {&#10;            if (cardStatistic.getValue() &gt; maxErrors) {&#10;                hardestCard = cardStatistic.getKey();&#10;                maxErrors = cardStatistic.getValue();&#10;            }&#10;        }&#10;        printLnOut(String.format(&quot;The hardest card is \&quot;%s\&quot;. You have %d errors answering it.&quot;, hardestCard, maxErrors));&#10;    }&#10;&#10;    private void saveLog(Scanner s) {&#10;&#10;        printLnOut(&quot;File name:&quot;);&#10;        String fileName = getInput(s);&#10;&#10;        File saveFile = new File(savePath + fileName);&#10;&#10;        try (FileWriter fileWriter = new FileWriter(saveFile)) {&#10;            for (String logLine : appLog) {&#10;                fileWriter.write(logLine);&#10;            }&#10;            printLnOut(&quot;The log has been saved.&quot;);&#10;        } catch (IOException e) {&#10;            printLnOut(&quot;The log has not been saved.&quot;);&#10;        }&#10;    }&#10;&#10;    private void resetStats() {&#10;        for (Map.Entry &lt;String, String&gt; card: cardToDefinition.entrySet()) {&#10;            cardStatistics.put(card.getValue(), 0);&#10;        }&#10;        printLnOut(&quot;Statistics have been reseted&quot;);&#10;    }&#10;&#10;    private void importCards(Scanner s) {&#10;        printLnOut(&quot;File name:&quot;);&#10;        String fileName = getInput(s);&#10;&#10;        File saveFile = new File(savePath + fileName);&#10;&#10;        try (Scanner fileReader = new Scanner(saveFile)) {&#10;            boolean isDefinition = false;&#10;            boolean isMistakes = false;&#10;            int pairIndex = 0;&#10;            LinkedHashMap&lt;Integer, String&gt; cards = new LinkedHashMap&lt;&gt;();&#10;            LinkedHashMap&lt;Integer, String&gt; definitions = new LinkedHashMap&lt;&gt;();&#10;            LinkedHashMap&lt;Integer, Integer&gt; mistakes = new LinkedHashMap&lt;&gt;();&#10;&#10;            while (fileReader.hasNextLine()) {&#10;                String importString = fileReader.nextLine();&#10;                if (!isDefinition &amp;&amp; !isMistakes) {&#10;                    cards.put(pairIndex, importString);&#10;                    isDefinition = true;&#10;                } else if (isDefinition) {&#10;                    definitions.put(pairIndex, importString);&#10;                    isDefinition = false;&#10;                    isMistakes = true;&#10;                } else {&#10;                    mistakes.put(pairIndex, Integer.parseInt(importString));&#10;                    pairIndex++;&#10;                    isMistakes = false;&#10;                }&#10;            }&#10;            for (Map.Entry &lt;Integer, String&gt; entry : cards.entrySet()) {&#10;                cardToDefinition.put(entry.getValue(), definitions.get(entry.getKey()));&#10;                definitionToCard.put(definitions.get(entry.getKey()), entry.getValue());&#10;                cardStatistics.put(entry.getValue(), mistakes.get(entry.getKey()));&#10;            }&#10;&#10;            printLnOut(String.format(&quot;%d cards have been loaded.&quot;, pairIndex));&#10;&#10;        } catch (FileNotFoundException e) {&#10;            printLnOut(String.format(&quot;%d cards have been loaded.&quot;, 0));&#10;        }&#10;    }&#10;&#10;    private InputAction inputAction(Scanner s) {&#10;        StringBuilder actions = new StringBuilder();&#10;&#10;        ArrayList&lt;InputAction&gt; actionsList = new ArrayList&lt;&gt;();&#10;&#10;        Collections.addAll(actionsList, InputAction.values());&#10;        Iterator actionsIterator = actionsList.iterator();&#10;&#10;        while (actionsIterator.hasNext()) {&#10;            InputAction action = (InputAction)actionsIterator.next();&#10;            actions.append(action.toString().toLowerCase().replace('_', ' '));&#10;            if (actionsIterator.hasNext()) {&#10;                actions.append(&quot;, &quot;);&#10;            }&#10;        }&#10;        printLnOut(String.format(&quot;Input the action (%s):&quot;, actions.toString()));&#10;        String userAction = getInput(s);&#10;        try {&#10;            return InputAction.valueOf(userAction.toUpperCase().replace(' ', '_'));&#10;        } catch (IllegalArgumentException e) {&#10;            printLnOut(&quot;Invalid input. Try again.&quot;);&#10;            return inputAction(s);&#10;        }&#10;    }&#10;}&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1562385275000" />
                    </EduTask>
                  </list>
                </option>
              </FrameworkLesson>
            </list>
          </option>
        </HyperskillCourse>
      </option>
    </StudyTaskManager>
  </component>
</project>